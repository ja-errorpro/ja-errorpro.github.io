<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ErrorPro</title><link>/</link><description>Recent content on ErrorPro</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>中原111資工計概上學期期中機測</title><link>/posts/2022/cycu_cal111_midterm/</link><pubDate>Mon, 07 Nov 2022 00:00:00 +0000</pubDate><guid>/posts/2022/cycu_cal111_midterm/</guid><description>(本人已放棄思考) 答案僅供參考 答案僅供參考 答案僅供參考 鬼才知道是不是正解 pA 實作NotLetter(char ch) function，如果ch不是字母就回傳true，反則false。
1 2 3 4 5 6 7 bool NotLetter(char ch){ if(ch &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;z&amp;#39;) return false; if(ch &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;Z&amp;#39;) return false; return true; } 補：事實上在 ctype.h已經有 isalpha() 可使用，但這裡不允許include其他東西。
pB 實作MonotonicIncreasing() function，讀入若干個整數，直到-99999，如果數組(不含-99999)非單調遞增則回傳false，否則或如果只有一個數則回傳true。
1 2 3 4 5 6 7 8 9 10 11 12 bool MonotonicIncreasing(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); while(n!=-99999){ int m; scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); if(m &amp;lt; n &amp;amp;&amp;amp; m !</description></item><item><title>【Git】Git分支的打開方式</title><link>/posts/2022/git_branch/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>/posts/2022/git_branch/</guid><description>當一個專案有許多人一起開發時，不能隨便commit，因此當需要增加功能、修正bug時可以開一個分支來進行，確認沒問題後再合併，就不會影響主要的生產線。
初始化Local Repo 詳見 上一篇文章
查看現在有哪些分支 1 $ git branch Output:
1 * master 新增分支 1 $ git branch main 這樣就會新增一個名為main的分支，但是還沒有切換到該分支，所以還是在master分支上。
重新命名分支 1 $ git branch -M cool # 將目前分支重新命名為cool 或者
1 $ git branch -m main cool # 將main分支重新命名為cool分支 刪除分支 1 $ git branch -d main # 刪除main分支 這時候可能會看到 error: The branch 'main' is not fully merged，因為main還沒被合併，不給刪除
可以使用 -D 強制刪除
1 $ git branch -D main 切換分支 1 $ git checkout main 如果分支不存在，可以使用 -b 來建立並切換到該分支</description></item><item><title>【Git】Git初始設定與環境</title><link>/posts/2022/git_initial/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>/posts/2022/git_initial/</guid><description>What is Git? 能夠紀錄更新歷史紀錄，進行復原(Rollback)、比較、合併(Merge)等等的分散式版本控制系統。 讓開發者(群)能夠更好管理專案。
分散式與中央式版控系統 中央式版控系統 需要一台伺服器，所有版本控制功能必須在這台伺服器上運作，如果伺服器壞了或沒網路就無法使用
分散式版控系統 即使沒有網路也能使用，可以先在本機版控直到能連上伺服器後再同步。
Git環境 Local Repo 我們在修改完檔案後，透過git add 將檔案加入暫存區，再透過git commit將檔案加入Local Repo。
Remote Repo Remote Repo是一個遠端的Git伺服器，我們可以將Local Repo push 到 Remote Repo，也可以從Remote Repo pull 到 Local Repo。
Git安裝 Windows 到以下網址下載合適的版本並進行安裝
Git for Windows
安裝過程直接按到底即可，接著打開Git Bash，可從開始功能表或是桌面右鍵選擇Git Bash Here。
這套軟體能模擬Linux的環境，所以我們可以在這裡使用Linux的指令。
Linux 非常簡單，打開你的終端機
1 2 $ sudo apt update $ sudo apt install git -y 初始設定 1 2 3 4 5 $ git config --global user.name &amp;#34;你的名字&amp;#34; $ git config --global user.</description></item><item><title>About</title><link>/about/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>/about/</guid><description>我是誰 黃乙家 weak
現在是待在CYCU ICE的
小廢物
IG: cannot.load_connection.refused
神秘的終端
你可以試試輸入 YI_JIA{this_is_so_cool}
沒用嗎？要不要換個瀏覽器試試看？</description></item><item><title>【Discord 聊天機器人】 - Discord interactions.py 介紹與開始</title><link>/posts/2022/discordpy2_and_interactions/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>/posts/2022/discordpy2_and_interactions/</guid><description>Why discord-py-interactions(以下簡稱 dcpi)? 支援更多操作如斜線指令、按鈕、選單，且簡單易懂
簡介 經過大量搜尋資料，發現dcpi的介紹特別少， 因此閱讀完官方API後想記錄下來翻成中文並做個整理。
先備知識 需知道如何在 Discord Developers Applications 裡創建機器人 需知道命令列的基本操作 環境建置 既然是py當然要安裝Python(目前已測試3.8~3.10可用)
Python官網
安裝 dcpi(以編寫此篇文時的版本為主)
dcpi Pypi
1 $ pip3 install discord-py-interactions==4.3.4 Quick Start 根據這份API文件
我們先創建一個專門放Discord Bot的資料夾，然後在裡面新增一個檔案名為bot.py， 並在DC的開發應用頁面創建好機器人
然後複製以下code，將your-bot-token換成機器人的token，注意不要將token公開給別人。
1 2 3 4 5 6 7 8 9 # 導入interactions套件，如果報錯的話檢查一下環境建置是否有問題 import interactions # 宣告bot這個變數為一個客戶端，記得將your-bot-token改成Discord bot的token # 我們需要告訴Discord我們要監聽哪些事件，透過設定intents達成 bot = interactions.Client(token=&amp;#34;your-bot-token&amp;#34;,intents=interactions.flags.Intents.ALL) # 啟動機器人 bot.start() 接著執行它
1 $ python3 bot.py 這樣我們的機器人就成功上線了
第一個斜線指令 修改程式碼
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import interactions bot = interactions.</description></item><item><title>【CTF-WriteUp】PicoCTF-file-run2</title><link>/posts/2022/ctf_picoctf_file_run2/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>/posts/2022/ctf_picoctf_file_run2/</guid><description>題目：
給你一個檔案，執行它時輸入&amp;quot;Hello!&amp;quot;(不含引號)。 概念： 逆向工程 Linux 指令操作 Linux 權限控制 題解 丟進IDA看看，發現確實只要輸入Hello!就能跑出Flag，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 main(int param_1,long param_2){ int var1; if ((param_1 &amp;lt; 2) || (2 &amp;lt; param_1)) { puts(&amp;#34;Run this file with only one argument.&amp;#34;); } else { var1 = strcmp(*(char **)(param_2 + 8),&amp;#34;Hello!&amp;#34;); if (var1 == 0) { printf(&amp;#34;The flag is: %s&amp;#34;,flag); } else { puts(&amp;#34;Won\&amp;#39;t you say \&amp;#39;Hello!</description></item><item><title>gdb 除錯工具學習</title><link>/posts/2022/gdb/</link><pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><guid>/posts/2022/gdb/</guid><description>What is GDB? gdb全名為gnu debugger，是一種動態Debug的工具。
使用 我們可以先寫一個簡易的Hello World，並宣告一些變數
1 2 3 4 5 6 7 8 # include&amp;lt;stdio.h&amp;gt; int main(){ int a = 5; int b = a * 6; int c = b + 4; printf(&amp;#34;Hello World\n&amp;#34;); return 0; } 記得在編譯時加上參數 -g，否則gdb將提示找不到除錯符，加了只差在程式大小會變大。
1 2 $ gcc -g hello.c -o hello $ gdb ./hello 指令 指令 簡寫 簡述 help h 查看指令說明 list l 印出程式碼 file 開啟檔案 run r 執行程式 kill 停止程式 breakpoint b, bre, break 設定斷點 ex: b 15表示執行到第15行 continue c, cont 繼續執行 next n 步過(遇到呼叫函式會將該函式當成一條指令執行) step s 步入(遇到呼叫函式會進入函式一步一步執行) print p 印出變數的值 ex: p num display 每次步過/入後印出變數值 ex: display num info 查看特定資訊 ex: info break查看設了哪些斷點，不輸入參數可查詢指令 quit q 離開gdb，或按Ctrl+C &amp;lt;Click&amp;gt; Enter 執行上一條指令</description></item><item><title>Vim 極簡教學</title><link>/posts/2022/vim_simple_tutorial/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>/posts/2022/vim_simple_tutorial/</guid><description>簡介 Vim是一種開源的編輯器，是Vi的進化版，由於操作方便，有許多人很愛用，是作為Linux OS主要的編輯器之一。
起步 若要使用vim編輯檔案，請在命令列中輸入 vim xxx.yyy，如果xxx.yyy存在就會直接進入普通模式並可瀏覽檔案；
如果不存在，就會在儲存後新建一個。
模式 Vim主要有四種模式： 普通模式、編輯模式、視覺模式、指令模式
普通模式 初始畫面，可使用方向鍵控制游標，或用Page UP/Down換頁，而任何有關編輯的指令都要在此模式下進行
以下是常用的編輯指令
dd - 刪除整行 (n)dd - 刪除從游標往下數n行 yy - 複製整行 (n)yy - 複製從游標往下數n行 u - 復原(undo)動作 Ctrl+r - 重做(redo)動作 . - 重複上一個動作 x - 刪除字元 X - 刪除前一個字元(Backspace) &amp;gt;&amp;gt; - 縮排 &amp;lt;&amp;lt; - 反向縮排 編輯模式 在普通模式按下 i(Insert), o(Open), a(Append) 等鍵就會進入編輯模式，此時可以看到視窗最下方出現 -- INSERT --，即可對檔案編輯
按下 Esc 即可回到普通模式，此時 -- INSERT -- 會消失
視覺(選取)模式 在普通模式按下 v 即可進入視覺模式，此時可以看到視窗最下方出現 -- VISUAL --，可以使用方向鍵選取文字，並使用 w 選取下一個單字的開頭或 $ 選取後面整行。</description></item><item><title>VSCode設定C++教學(Code Runner)</title><link>/posts/2022/vscode_cpp_setup/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>/posts/2022/vscode_cpp_setup/</guid><description>遇到很多來問我VSC怎麼設定C/C++的問題，這裡直接寫篇文來說明我的作法。
前置 環境(以撰寫此篇文時的環境為主)： Windows 11(64 bit) 22H2 Visual Studio Code 1.71 7-Zip 目標 配置GCC 12 MinGW-w64 不含Clang 之編譯器 成功在VSCode裡編譯並執行一支C/C++程式 過程 一、安裝延伸模組： C/C++、Code Runner 二、下載編譯器：範例為GCC 12.2.0 + MinGW-w64 10.0.0 without Clang 請到這個網站
下載編譯器(視個人需求選擇一種編譯器)，並解壓到任意空間，(ex: C:/)
三、設定環境變數 Windows設定 -&amp;gt; 系統 -&amp;gt; 裝置規格 -&amp;gt; 進階系統設定 -&amp;gt; 環境變數 -&amp;gt; 系統變數(使用者環境變數)
在變數名 Path 中添加路徑(剛剛解壓到的路徑/bin/)
完成後打開cmd(命令提示字元)或Terminal，輸入 gcc -v，如果成功的話就會在最後一行看到 gcc version 12.1.0 字樣。
四、設定VSCode 打開VSCode，點擊左下角齒輪，然後找到右上角功能欄中的 開啟設定(JSON)，在最外面的{}裡貼上以下範例設定
1 2 3 4 5 6 7 &amp;#34;code-runner.executorMap&amp;#34;:{ &amp;#34;c&amp;#34;: &amp;#34;cd $dir &amp;amp;&amp;amp; gcc $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&amp;#34;, &amp;#34;cpp&amp;#34;: &amp;#34;cd $dir &amp;amp;&amp;amp; g++ -std=c++11 -O2 $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&amp;#34; }, // 編譯並執行指令，其中設定項 -std= 後面可接C++版本 (98,11,14,17,20,.</description></item><item><title>大學面試心得</title><link>/posts/2022/college_interview/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>/posts/2022/college_interview/</guid><description>申請入學(新課綱第一屆白老鼠) 身為2003/9月出生的我，變成教育部爆改課綱的頭一批白老鼠orz&amp;hellip;，可謂生於SARS，死於武漢！
以為今年數學會比110簡單，結果更難😠，我的學測直接燒到只剩43級分。
聽到這成績後我還是硬著頭皮把六個志願全都填電資/資工，
以下是我的一階正取校系以及二階面試狀況(20220530更新: 穩到不行欸好讚)：
中原資工 - 疫情取消面試 - 備14 中原資電不分系 - 疫情取消面試 -正8 逢甲資電不分系 - 521面試結束 - 正30 元智資工 - 無面試 - 正76 東海資工 - 522面試結束 - 正3 哭啊只剩兩間面試，飯店都訂好了，直接噴掉1000
面試過程 逢甲資電不分系: 印象不錯，有熱情的學長姊(?，進去前會一直跟我們聊天(降低緊張感？
而且教授非常友善、和藹(幸運遇到白臉)~ 聽說另一間試場是黑臉教授
面試方式是一次六個人對三位教授，大概是這樣坐的：
教授 教授 教授
------長桌------
1(沒來) 2 3 4 5 我(6) 門
一開始教授讓我們輪流自我介紹，
而當右邊的教授聽到我參加APCS跟能競就問學過什麼語言，然後從我開始倒序輪流回答(我忘了講資奧初選被旁邊講走orz&amp;hellip;。
接著教授就問還有什麼問題
我問了有關往國外發展的條件，然後其他人也都問一問時間就到了。
整場就像是跟教授在聊天而已，真的不用太緊張，
第一天面試感覺非常好，希望第二天東海也能順利~
東海資工資電組: 一人對三個教授，而且也非常友善不用緊張
首先自我介紹，然後
教授(簡稱P): 你的經歷滿豐富的，分享一件你印象深刻的歷程跟收穫
我說了Farmbot(點我查看)的事
P: 你APCS考得不錯為什麼不填APCS組
我: 我認為APCS就是測驗自己的程式能力，沒有把他當我的入學管道
P: 我覺得你備審用Linux介面當封面的想法很有創意，而且你也有提到之前參加我們學校的AI營隊&amp;hellip;
^當事封面
P: 你還有報哪些科系，如果都上會選哪間
我回答比較保守，把每間優點都講出來後說再考慮</description></item><item><title>【TIOJ】1903-你的笑容由我來守護-EXTREME</title><link>/posts/2022/tioj1903/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>/posts/2022/tioj1903/</guid><description>題目： 給一張$N$個點的無向圖，一開始有$M$條邊。 接著$Q$個操作，有以下兩種：
增加一條連著$A_i$、$B_i$的邊。 刪除一條連著$A_i$、$B_i$的邊(保證這條邊存在)。 每次操作完後輸出當前連通塊數量。
$1 \le N \le 5e5$ $M+Q \le 5e5$ $0 \le A_i,B_i \le N-1$ $A_i \neq B_i$ 輸入： 第一行有一個數字T代表測資筆數。
每筆測資第1行有3個整數N、M、Q。
接下來M行每行兩個整數Ai、Bi，代表Ai和Bi這兩個人目標相同。
接下來Q行，每行有一個字元 c 和兩個整數Ai、Bi，代表修改一個紀錄。
如果 c 是 N，代表增加一筆 Ai、Bi 兩人目標相同的紀錄；
如果 c 是 D，代表要刪除一筆 Ai、Bi 目標相同的紀錄，所有刪除都是合法的。
輸出： 對於每筆測資的Q筆修改，每次修改完輸出一行代表連通塊數量。
Ex 1 Input: 2 3 0 3 N 0 1 N 1 2 N 2 1 3 3 3 0 1 1 2 2 1 D 2 1 D 0 1 D 2 1 Ex 1 Output: 2 1 1 1 2 3 題解： 動態維護連通塊數量可以使用並查集(DSU)，但多了刪除的操作。</description></item><item><title>【CTF-WriteUp】EasyCTF-adder</title><link>/posts/2022/ctf_easyctf_adder/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><guid>/posts/2022/ctf_easyctf_adder/</guid><description>題目：
給你一個加法程式，找出Flag adder
概念： 反編譯 題解 在linux執行程式，看到要你輸入三個數，先隨意輸入，發現輸出nope。
開啟反編譯工具Ghidra對檔案反編譯，發現在main函式中的flag前綴，
而只要讓該行上面的if條件成立應該就能得到flag，顯然我們只要輸入三個數讓他加起來等於 0x539 即可。
透過簡單的進位換算，得$539_{16}\ =\ 1337_{10}$
開啟程式輸入1337 0 0 就可以拿到flag了~</description></item><item><title>網站搬家~</title><link>/posts/2022/newborn/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/newborn/</guid><description>我把網站從Jekyll改到Hugo了 因為111學測已經很久沒更新了，今天終於把網站搬遷成功，整個網站比以前看起來更舒服~
Hugo比起Jekyll更容易客製化，可以使用更多插件，之後有空就把留言系統加一加ㄅ~~</description></item><item><title>自架CodeServer，實現隨時隨地都能寫程式</title><link>/posts/2022/codeserver/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/codeserver/</guid><description>最近架了一台CodeServer，那是一個具有VSCode的伺服器平台，要他支援什麼語言照著一般設定VSC2方式就行~
先備條件： 會用Windows跟Ubuntu Docker以及容器的基礎操作 參考資源： codercom/Code-server
本文所用配備及版本： 物理機環境： Windows 11 Pro 21H2 Code Server版本： v4.0.2 步驟 (這裡省略前面Docker的安裝步驟)
先開一個資料夾名為CodeServer，這是伺服器的根目錄 新增一個檔案，檔名為docker-compose.yml 編輯檔案，貼上這些： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: &amp;#34;2.1&amp;#34; services: code-server: image: codercom/code-server container_name: code-server environment: - TZ=ASIA/TAIPEI - PASSWORD=&amp;lt;設定進入伺服器的密碼&amp;gt; - SUDO_PASSWORD=&amp;lt;設定Root權限的密碼&amp;gt; volumes: - ./appdata/code-server/project:/home/coder/project - ./appdata/code-server/.local:/home/coder/.local ports: - &amp;lt;PORT&amp;gt;:8080 restart: always (1) version: 不用動他
(2) image: 指定目標映像，Docker會試著到上面給的網站找尋映像檔
(3) container_name: 給容器隨便取一個名字
(4) TZ: Timezone時區</description></item><item><title>區間詢問比K小的數量</title><link>/posts/2021/mergesorttree/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mergesorttree/</guid><description>今天是資訊能競校內初選，沒把經典題做出來真的很可惜。
所以來刻點線段樹緩下心情(?
順便測試一下在網站中使用 $ \LaTeX $
先要基礎： 線段樹、二分搜、排序
合併排序樹 合併排序樹是一種線段樹，節點上都是一個向量(Vector)， 比如節點的範圍是[l,r]，則節點上向量就是已排序過的array[l~r]。 題目： 輸入 $n$ 個數到陣列 $A$，然後輸入一個 $q$ 代表詢問次數。
接著每次詢問有三個數 $l,r,k$ 代表詢問的區間$[l,r]$ 有幾個數比 $k$ 小。
其中，$ 1 \le n,q \le 2*10^5$，且陣列中沒有重複數字。
輸入： 首先輸入一整數 $n$，
再來一行有$n$個數代表 $a_i(1 \le a_i \le 10^9)$。
接下來一行輸入整數$q$，
接著有 $q$ 行分別輸入 $l,r,k$。
輸出： 一個整數代表在 $[l,r]$ 區間內有幾個數比 $k$ 小。
Ex 1 Input: 10 5 2 1 9 10 4 8 7 6 3 5 1 10 6 4 8 7 6 9 4 1 8 5 2 7 10 Ex 1 Output: 5 1 0 3 5 Note: 第一個詢問區間 $[1,10]，k=6$，其中比k小的元素有:$ {5,2,1,4,3} $，共$5$個。</description></item><item><title>103年彰雲嘉P5 - Infix to Postfix</title><link>/posts/2021/mtwcp103_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp103_5/</guid><description>題目： 一般我們在表示運算式時，是使用中序式，是將運算子放在兩運算元中間， 比如 (A+B)*(C+D)。而在電腦中，需要將中序式轉成後序式以方便運算。 (A+B)*(C+D)的後序式為 AB+CD+*； A*(B+C)-D*E+F 的後序式為 ABC+*DE*-F+ 。 請寫一程式將中序式轉成後序式。 輸入： 輸入一個中序運算式，其中運算元為A~Z等26個單一字母表示，運算子只包含+、-、*、/。 運算式中可有任意多個括號，且保證輸入的式子合法。 輸出： 輸出後序式。 Ex 1 Input: 中置式: (A+B*(C-D)+E)* ((F+G)/(H*I)+J) Ex 1 Output: 後置式: ABCD-*+E+FG+HI*/J+* 題解： 需要注意的是四則運算的優先序(括號先算，由左到右，先乘除，後加減)。
這題是非常經典的堆疊資料結構應用題，用 getline 輸入，遇到運算子就加入堆疊，
先看括號，然後看加減乘除，如果遇到 ) 的話，就把堆疊的運算子都輸出直到碰到 ( 為止。
而運算元則直接輸出就行。
(我的編譯器因為格式問題輸出不了中文&amp;hellip;反正程式碼對就好)
這問題可以再延伸，比如以中序式進行四則運算輸出結果，
跟這題做法很像只要把中序轉成後序然後讀一遍，
遇到運算子就把前面讀到的數字做運算後放入堆疊，注意運算子可能有多位數。
補充：這種需要stack的題目通常能用遞迴完成，因為遞迴本身就是一種堆疊。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>107年彰雲嘉p3 - GCD &amp; LCM</title><link>/posts/2021/mtwcp107_3/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_3/</guid><description>題目： 給你一堆數字(&amp;gt;=0)，求他們的GCD(最大公因數)與LCM(最小公倍數) 輸入： 一堆數字以空格分開，最後以0結束 輸出： 所有數字(除了0以外)的GCD跟LCM，以空格分開 Ex 1 Input: 10 20 30 0 Ex 2 Input: 3 5 7 9 12 0 Ex 3 Input: 100 100 200 0 Ex 1 Output: 10 60 Ex 2 Output: 1 1260 Ex 3 Output: 100 200 題解： 就是一題簡單的數論題， 可以根據歐幾里得算法 gcd(a,b-a) = gcd(a,b mod a), gcd(a,0) = |a| (輾轉相除)來求GCD， 那LCM要怎麼求？我們知道 a | (a*b) 且 b | (a*b) (a*b必為ab公倍數) 如果要得到最小公倍數，只要除以gcd(a,b)就行。
當我們在計算mod時，要注意有沒有負數問題，因為C++的算法會使負數模運算出差錯， 建議使用((a%b)+b)%b 來取代 a%b，這樣就能簡單避開負數取模的問題了。 還好這題輸入並沒有負數，但之後做模運算時請稍加注意。</description></item><item><title>107年彰雲嘉P6 - 統一發票對獎程式</title><link>/posts/2021/mtwcp107_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_6/</guid><description>題目： Ex 1 Input: 73372972 22315462 91903003 16228722 03270598 163 983 814 73372971 22315461 91903001 16228722 13210598 03210163 0 Ex 1 Output: 201200 題解： 前三個獎直接判別，後面判別如果你用int，就 mod pow(10,i)；
如果你用字串，直接複製 string s1(s.begin()+i,s.end())。
這裡使用字串判別。
判定順序可以任意，總之記得符合條件就一定要break不然會多算。
增開六獎跟持有號碼數量雖然不一定，但他們長度都是固定的，
string直接s.size()，而int你可以透過除以1000 == 0? 判別。
這裡直接把六獎當增開六獎判定，反正結果一樣。
官方測資的獎金不會超過$2^{31}$，所以不會溢位。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉上午P5 - 魔術三角形</title><link>/posts/2021/mtwcp108_1_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_5/</guid><description>題目： 魔術三角形是一個由1到9的數字所形成之三角形， 每邊由4個數字組成，邊與邊之間會有1個數字共用，而且每個邊 4個數字相加之總和是一樣的，舉例來說，下圖是一個魔術三角形，三個邊的數字和均為19。 我們以三角形最上面的數字7為起點，順時針方向列出所有9個數字來表示這個三角形， 表示為&amp;quot;781359264&amp;quot; (取自108年彰雲嘉資訊科能力競試上午場P5)
預先將下圖的三個藍色粗框部分填入數字，請填入其餘數字使其成為一個魔術三角形。 (取自108年彰雲嘉資訊科能力競試上午場P5)
輸入： 三個1~9之間的數代表依順時針填入藍色粗框的3個數字。 輸出： 將形成的魔術三角形之9個數字合併成一個十進位數字輸出，若存在多個答案 ，則輸出十進位數字最小者。若無法形成魔術三角形，則輸出1個0。 Ex 1 Input: 4 3 6 Ex 2 Input: 4 6 7 Ex 1 Output: 542937168 Ex 2 Output: 249561873 題解： 題目沒給時間限制，當然直接暴力做下去啊！
時間複雜度也只有O(6!) = O(720)，
所以也不會超過1秒
可使用next_permutation()這個函式，
他是用來枚舉排列的工具，既然是排列，
有學過排列組合都知道不重複排列數是P(n,n)
那時間複雜度就會是O(P(n,n))=O(n!)
如果遇到排列數很多的就還是別用了吧
記得在用這個函式時要先把要排的數組先排序好，
才能完整枚舉所有排列。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉上午P6 - Knight Moves</title><link>/posts/2021/mtwcp108_1_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_6/</guid><description>題目： 西洋棋騎士/象棋的馬每步可以沿日字對角走到另一對角， 現在有一個X*Y的棋盤，左下角座標(0,0)，右下為(X-1,0) 棋子的起始點為(a,b)，請求出走到(c,d)的最小步數。 其中X,Y&amp;lt;=10000 輸入： 本題有多筆測資，第一行輸入N代表有幾筆測資 接下來每筆測資有一行， 依序以空格分開輸入6個正整數X, Y, a, b, c, d 輸出： 針對每筆測資依序輸出最短步數 Ex 1 Input: 2 10 10 3 4 7 6 10 10 3 4 9 9 Ex 1 Output: 2 5 題解： 如果還是不懂騎士走法可參考 維基百科
這題是非常經典的最短路問題，可使用BFS(廣度優先搜尋)解。
可以想像有一個確診武漢肺炎的同學坐在班上位置中間，
而病毒就從那位同學開始往旁邊擴散，
每過一天就一個確診，
最後全班都被感染病毒，
然後就能求哪位同學會在第幾天確診。
其原理是利用佇列(&amp;lt;queue&amp;gt;)，造訪所有圖上的位置，
並記錄從起點到每個位置一共走了多少步。
騎士走法是按照日字走的，因此可推論一個點會有八種走法
而步數就是上一個點的步數再+1
上程式碼(當然你可以用struct建立點佇列，就不用宣告那麼多queue跟陣列了)：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉下午P10 - Huffman</title><link>/posts/2021/mtwcp108_2_10/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_2_10/</guid><description>題目： Huffman ： 維基百科
霍夫曼樹經常被用來作資料壓縮，將字串資料轉成霍夫曼碼以減少字串資料所佔的空間大小，其詳細作法如下： (1)字串中所有的字母元素都放在最底層的葉節點上，節點中的值為此字母的出現次數。 (2) 每次從尚無父節點的所有節點中，尋找值最小（出現次數最少）的兩個節點來建立霍夫曼樹， 產生其父節點的值為兩個節點值相加的和。最後只剩下根節點沒有父節點。 (3) 從根節點開始往下編碼，左分支為 0，右分支為 1，每個葉節點的字母元素會產生一個霍夫 曼碼（由 0 和 1 所組成），字母元素出現的頻率越高則霍夫曼碼越短。 我們這題需要計算一個字串轉成霍夫曼碼的壓縮率。假設有個字串&amp;quot;queue&amp;quot;，則此字串會佔5 bytes = 40bits空間， 轉成霍夫曼碼後應為&amp;quot;00011011&amp;quot;，只需要8個bits就可儲存，因此壓縮率為(40-8)/40 * 100% = 80%。 輸入： 輸入一列字串(長度最多100字元，且不含空格)。 輸出： 依序輸出此字串壓縮前的bit數、壓縮後的bit數、壓縮率百分比(格式為⌊n⌋%，即n向下取整)。 Ex 1 Input: queue Ex 2 Input: abadcafcabfdec Ex 3 Input: aaaaaaamcmhhhhhmkkkkkkkkmbbmdddddddmyymppppp Ex 4 Input: BCBBB Ex 1 Output: 40 8 80% Ex 2 Output: 112 35 68% Ex 3 Output: 352 132 62% Ex 4 Output: 40 5 87% 題解： 題目沒說字串中大小寫是否要算成同一字母，因此先視為不同的來處理。</description></item><item><title>Farmbot歷程</title><link>/posts/2021/farmbot/</link><pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate><guid>/posts/2021/farmbot/</guid><description>Farmbot
(本頁面在舊版網站發布，會有不少顯示問題)
FBTUG共筆資料
什麼是Farmbot? 一個機器人開放式系統，可通過土地種植，澆水，土壤測試和除草為所有需要耕種小土地跟想種糧食的人提供幫助
使用Raspberry Pi(樹莓派)，Arduino以及其他優良組件
1.碳足跡 製造 目前看重環保議題,Farmbot使用最普遍的材料:
材料 用途 重量(kg) kg CO2/物料 kg CO2(kg) 鋁 擠壓板 9.5 8.24 78.3 不鏽鋼 硬件，軸承，驅動軸，絲槓 1.4 6.15 8.6 塑料 拖鏈，3D列印[CAD]，輪子，電子設備，管材，電路板 2.8 2.53 7.1 銅 電，佈線，電動機繞組 0.3 2.60 0.8 橡膠 皮帶，電線，墊片 0.2 3.18 0.6 合計 95.4 每生產Farmbot排放的理論量約 95.4 kg，但實際上較接近 150 kg
使用 在使用Farmbot時，最明顯的CO2排放源應為用電量，在此使用美國平均每千瓦時所排放的二氧化碳量 (0.554kg/kWh)
零件 功率(W) 佔空比(%) 使用時間(h/d) kWh/day kWh/year kg CO2/day kg CO2/year 樹莓派2 3.0 100% 24.00 0.072 26.3 0.040 14.56 樹莓派相機 1.</description></item><item><title>Python遊戲設計</title><link>/posts/2021/pythongame/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>/posts/2021/pythongame/</guid><description>FOR Python遊戲設計 檔案庫: Here
Python程式列表(全自寫): LIST
Cocos2d: Docs
第一堂: IDE: pycharm CE, Module: cocos2d 彭彭-Python程式設計入門
Colab
CBE30338
記得寫程式可放個小抄在旁邊&amp;hellip;
有問題請點這個
作業: 遊玩CodeCombat
第二堂 安裝Pycharm : Pycharm
Community版為開源,免費 / Professional為完整版(30天免費試用)
需要先安裝Python (Ver. &amp;gt;3.7),Windows:可在Microsoft市集搜尋Python / MacOS可在官網上下載 / Linux有些版本已預安裝,安裝方式: ($ apt update &amp;amp;&amp;amp; apt install python3)
安裝方式: Here
設定: here
安裝Cocos2d: Files&amp;gt;Setting&amp;gt;Project: Inter..&amp;gt;(+)&amp;gt;搜尋cocos2d&amp;gt;安裝
學程式的技巧: 先抄再讀 不懂可Google
Vim: 分為命令模式,插入模式,底線命令模式,視覺模式
命令模式: 為預設模式,在任何模式中按下Esc即可到此模式,可按下某些鍵來切換模式
插入模式: 切換方式:在命令模式中按下i,a,o等按鍵,可在游標位置插入需要的文字
底線命令模式: 切換方式:按下:,可輸入指令操作內容,
離開: :q
強制離開: :q!
存檔不離開: :w
強制存檔不離開: :w!
存檔並離開: :wq</description></item><item><title>C++筆記-語法</title><link>/posts/cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/</guid><description>*所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主
程式碼運作原理 我們知道其實電腦只懂0與1，因此想跟電腦溝通就需要透過一些轉譯，
在人類的世界中所使用的語言叫高階語言，而只由0與1數字組成的語言稱為機器語言，我們很難看懂，
要將高階語言轉成機器語言，就需要藉由編譯器與組譯器的幫忙，編譯器可以幫我們把程式碼轉成所謂的組合語言，此時階段
就會有很多人開始看不懂了，當然如果有學過還是能稍微看懂，但組合語言經過組譯器就會變成0跟1，只有電腦才看得懂。
基礎C++模板 附上STL標頭檔：
1 #include&amp;lt;bits/stdc++.h&amp;gt; 注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個
這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 &amp;lt;algorithm&amp;gt; 裡的__gcd(計算最大公因數)
不過有些編譯器不包含這個標頭檔，可以自己Google找到對應的解決方法。
有時候看別人的Code還會看到一個標頭檔 &amp;lt;bits/extc++.h&amp;gt; ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。
為了方便，會在下面定義名稱空間 using namespace std; ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣在做像是輸入輸出(cin、cout)等操作時 不需要在每個句子前面加上 std:: 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。 打個比喻，如果說標頭檔是圖書館，那std就是你想找的書。
而每個程式都會需要一個叫做main的主函式，這個函式就是整個程式的起點跟終點：
1 2 3 int main(){ return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。 } 在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。
注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在C++，&amp;ldquo;引入標頭檔&amp;quot;這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。
總結程式碼(模板)： 1 2 3 4 5 6 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 你會看到電腦跟你說Hello World return 0; } 註解 在上面兩個程式碼中，會看到裡面寫了 // 後面接上說明，稱為&amp;quot;註解&amp;rdquo;，註解的內容不會被編譯器讀取，註解有兩種模式： 單行註解及多行註解，在C++裡的語法是這樣的</description></item><item><title>You are Rickrolled</title><link>/embed/rickroll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/embed/rickroll/</guid><description/></item><item><title>留言區</title><link>/comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/comment/</guid><description/></item><item><title>算法筆記-DP-LIS</title><link>/posts/1/algo-dp-lis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-dp-lis/</guid><description>算法筆記目錄 最長遞增子列(Longest Increasing Subsequence) 考慮以下問題：
給一個序列，求一個最長的遞增子序列，如 [1,3,2,2,4,0] 中，最長的遞增子序列為 [1,3,4] 或 [1,2,4]。
定義狀態： $dp_i$ 代表掃到第$i$個數時的LIS長度
轉移式： $dp_i = max(dp_j\ | j&amp;lt;i \land a_j&amp;lt;i) + 1$ 表示當發現$a_j &amp;lt; a_i$，則LIS長度+1
邊界狀況： 最小的遞增子列至少為1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Top-Down #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int MAXN = 1005 int a[MAXN],dp[MAXN]; int DP(int i){ if(dp[i]&amp;gt;0) return dp[i]; dp[i] = 1; for(int j=0;j&amp;lt;i;++j) if(a[j]&amp;lt;a[i]) dp[i] = max(dp[i],DP(j)+1); return dp[i]; } int main(){ int n; cin &amp;gt;&amp;gt; n; for(int i=0;i&amp;lt;n;++i) cin &amp;gt;&amp;gt; a[i]; int ans = 0; for(int i=0;i&amp;lt;n;++i) ans = max(ans,DP(i)); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Buttom-Up #include&amp;lt;bits/stdc++.</description></item><item><title>算法筆記-初階資料結構</title><link>/posts/1/algo-primary-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-primary-structure/</guid><description>算法筆記目錄 初階資料結構 1.Segment Tree - 線段樹 Segment Tree是一種二元樹，適合解決RMQ問題(查詢區間極值)、區間和， 適合用於單點修改、區間修改。
成功實現Sparse Table做不到的事。
每個節點可以存一種區間的數據(比如區間和)，
根節點存[1,n]的數據，每個左子節點編號是index*2，右邊為index*2+1，
左邊紀錄[l,(l+r)/2)，右邊紀錄[(l+r)/2+1,r]。
通常，線段樹會開4倍大
1 int T[4*N],a[N]; // int T[N&amp;lt;&amp;lt;2]; 建立線段樹，若l==r，此節點即a[l] 子樹建完後就把資料合併
1 2 3 4 5 6 7 8 9 10 11 void build(int l,int r,int index){ if(l==r){ T[l] = a[l]; } else{ int mid = l+(r-l)/2; // 避免 (l+r)/2 溢位 build(index*2,l,mid); // build(index&amp;lt;&amp;lt;1,l,mid); build(index*2+1,mid+1,r); T[index] = T[index*2] + T[index*2+1] ; } } 詢問區間(ql,qr:要查的區間 l,r:此節點儲存的左右界) 1 2 3 4 5 6 7 8 int query(int ql,int qr,int l,int r,int index){ if(ql&amp;lt;=l &amp;amp;&amp;amp; qr&amp;gt;=r) return T[index]; int mid = l+(r-l)/2; int rt=0; if(ql&amp;gt;mid) rt+=query(ql,qr,mid+1,r,index*2+1); if(qr&amp;lt;=mid) rt+=query(ql,qr,l,mid,index*2); return rt; } 單點修改 1 2 3 4 5 6 7 8 9 void modify(int l,int r,int pos,int index,int val){ if(l==r){ T[index] = val;return; } int mid = l+(r-l)/2; if(pos&amp;lt;=mid) modify(l,mid,pos,index*2,val); else modify(mid+1,r,pos,index*2+1,val); T[index] = T[index*2]+T[index*2+1]; } 懶人標記 如果想在[l,r]中的所有元素加值怎麼辦？ 不可能一個一個呼叫modify吧。</description></item><item><title>算法筆記-基本資料結構</title><link>/posts/1/algo-basic-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-basic-structure/</guid><description>算法筆記目錄 基礎資料結構 我們程式想儲存東西有很多種方式，而資料結構就像一種容器，
可以儲存或拿取需要的東西，每種資料結構都有不同的複雜度，
如果用得好，效率就會高。
以下都是最基本的資料結構
1.Vector - 向量 in &amp;lt;vector&amp;gt; 1 vector&amp;lt;int&amp;gt; v; 向量可當成陣列來用，應該說它就是更強的陣列，而且易維護。
比起原本陣列，它可以自動擴大容量，
能用的空間也比陣列還多。但要注意的是，如果使用operator[]存取了未配置的記憶體位置，
會導致Segmentation Fault。
以下為vector的功能： -- vector[n] 存取索引值為n的元素 -- vector.at(n) 存取索引值為n的元素(較安全) -- vector.begin() 回傳指向vector第一個元素的疊代器 -- vector.end() 回傳指向vector最後一個元素再下一個的疊代器 -- vector.front() 回傳vector[0] -- vector.back() 回傳vector最後一個元素的值 -- vector.size() 回傳目前vector儲存了多少元素 -- vector.resize(n) 修改vector大小 -- vector.capacity() 存取可容納最大個數 -- vector.empty() 回傳布林值表示vector是不是空的 -- vector.reserve(n) 配置更多記憶體以容納更多元素 -- vector.push_back(n) 把n放到vector最尾端 -- vector.pop_back() 把vector最尾端元素取出 -- vector.insert(it,n) 在疊代器it後插入元素n -- vector.erase(it,(it2)) 刪除疊代器it~it2的元素 -- vector.clear() 刪除所有元素 -- vector.</description></item><item><title>算法筆記-常數優化</title><link>/posts/1/algo-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-io/</guid><description>算法筆記目錄 編譯器優化 我們的程式變成執行檔時需要經過一連串的轉譯與運算，
如果改變編譯器的編譯模式，或者改變寫程式的習慣，有可能會讓效率變更高。
一般的Judge編譯器模式都是O2，是個比較安全的運算方式。
但其實我們可以在程式中再加入一些指令，改變編譯器的運算方式。
1 2 3 4 5 6 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) //以較不安全的運算來編譯程式 #pragma loop_opt(on) //迴圈優化 #pragma comment(linker,&amp;#34;/stack:200000000&amp;#34;) //更改最大堆疊數 以上是我常用的編譯器優化指令，
請注意不是所有OJ都支援pragma優化。
I/O優化 當我們比較cout、cin與printf、scanf時，會發現後者比前者快非常多。
這是因為每次在輸入輸出前，程式會將資料放進一個緩衝區(內存)，然後再從內存裡拿出。
我們應該減少拿取的動作，因為這非常耗時。
如果做過CF互動題，會發現題目會要求在輸出後加上cout.flush()，就是要把資料強制輸出，
否則它可能要等到程式結束後才輸出。
cin，它的原理其實是讀取鍵盤輸入的字，再輸出給使用者看打了什麼，
這就讓拿取的動作暴增了，解決方法是加上 cin.tie(0);
讓內存強制釋放掉。
C++有兩種輸出輸入，分別是stdio與iostream，而程式可能會搞混而發生問題
，使得效率變差，這時就加上 ios_base::sync_with_stdio(false); 就解決了
加上這行後，之後的輸入輸出就是選(cin,cout)或(scanf,printf)其中一個，
絕對不要再混用。
C++的換行可以是endl或&amp;rsquo;\n&amp;rsquo;，而其實 cout &amp;lt;&amp;lt; endl 相當於 cout &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; flush
也就是它順便把內存清空了，做了多餘的動作。
之後記得要換行的話就用&amp;rsquo;\n&amp;rsquo;別再用endl了。 或放個 #define endl '\n'</description></item><item><title>算法筆記-排序</title><link>/posts/1/algo-sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-sorting/</guid><description>算法筆記目錄 排序 排序是將一串資料依優先度排列，通常是遞增、遞減、字典序排列，
可以自訂順序，這裡直接使用快速排序法，後面分治會提到合併排序，
快慢隨題目而變動。
我們學校會學到最經典的氣泡排序法，其實是個很不好的排序法，
它最差情況的時間複雜度會炸到$O(n^2)$。
在C++，有函數 sort() 可以直接排序，
以遞增排序為例，原理是先從資料群選一個基準點，
然後從資料兩邊往中間搜，若右邊比基準點小且左邊比基準點大，就將左右邊互換，
直到左右邊相遇，將相遇的點與基準點互換。
複雜度是$O(nlogn)$。
想體驗sort()的力量，我們用random_shuffle()這個函數來打亂區間。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; signed main(){ vector&amp;lt;int&amp;gt; a={9,8,7,6,5,4,3,2,1}; for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; random_shuffle(a.begin(),a.end()); for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; sort(a.begin(),a.end()); for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; return 0; } sort()預設是遞增排列，如果想遞減排列，可以在第三個引數加上 less&amp;lt;型態&amp;gt;()，</description></item><item><title>算法筆記-數論</title><link>/posts/1/algo-number-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-number-theory/</guid><description>算法筆記目錄 什麼是數論 數學的分支，專門研究整數的性質。
模運算 同餘 $a \equiv b \pmod n $ 表示 $n\ |\ (a-b)$ ( $n$ 整除 $a-b$ )，稱 $a$ 與 $b$ 模 $n$ 同餘。
比如
7 除以 3 餘 1
10 除以 3 餘 1
則可以說 $7 \equiv 10 \pmod 3$
證明: 對於 $a \equiv b \pmod k $
令 $a = ks + r,\ b = kt + r$
兩式相減得 $a-b = k(s-t)$
證明結束
加乘法性質 如果 $a \equiv b \pmod n $, $c \equiv d \pmod n $</description></item><item><title>算法筆記-時間複雜度概述</title><link>/posts/1/algo-runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-runtime/</guid><description>算法筆記目錄 時間複雜度在競程中是個非常重要且最基本的工具，
係用於估算程式執行N次，大概需要花多久時間。
我們在程式中做的任何事情可能都需要花費1單位時間，
比如五則運算、條件判斷、變數存賦等。
而我們通常會使用函式$O(Big-O)$ 來表示程式的複雜度。
對於$O()$，有以下定義：
$$ Def:\
\qquad If\ f(x) = O(g(x)),\ ∃M,x_0 &amp;gt; 0,\ such \ that \ ∀x&amp;gt;=x_0,then \ |f(x)| &amp;lt;= M|g(x)| $$
為什麼我們需要估時間複雜度？
因為我們在寫程式追求的是速度！當你的演算法太慢(時間複雜度太大)時，
就算結果是對的，但你會在Online Judge上或APCS得到一個TLE(Time Limit Exceeded)，
即若將測資丟到你的程式，會超出該題目所規定的執行時間。
要如何估自己的程式會跑幾秒？
通常，Judge的執行速度大約是1e8筆/秒，因此只要將題目的範圍限制代入所估複雜度，
然後除以1e8，就能大概知道自己程式會不會TLE了。
常見的複雜度有： $1,n,n^2,n^3,nlogn,2^n$。 而log通常以2為底但我們不太會去明指以誰為底。
以下是複雜度計算的原則：
&amp;ndash; 1.常數倍數不計( $O(2n) = O(n) = O(3n)$ )。
&amp;ndash; 2.若將程式分成兩段複雜度為$O(f(n)),\ O(g(n))$,總複雜度就取複雜度比較大的那段。
即$O(f(n)+g(n)) = O(f(n)) &amp;gt; O(g(n)) ? O(f(n)) : O(g(n))$
&amp;ndash; 3.若有一段程式複雜度為$O(f(n))$執行$g(n)$次，總複雜度是$O(f(n)*g(n))$。</description></item><item><title>算法筆記-枚舉與二分搜尋</title><link>/posts/1/algo-enum-and-searching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-enum-and-searching/</guid><description>算法筆記目錄 枚舉與搜尋 枚舉 枚舉，就是把全部或部分可能的情況都列出來，然後一個一個檢查是否符合條件，又稱窮舉。
雖然枚舉通常沒辦法在短時間內解決整個問題，但可以透過解決小問題來找到大問題的規律，或是用於檢驗時間複雜度較低的做法是否正確。
例題一 給一正整數 $n$，求 $n$ 的所有因數。
我們枚舉所有不超過 $n$ 的正整數，檢查每個數字是否為 $n$ 的因數，時間複雜度為 $O(n)$。
1 2 3 4 5 6 7 long long n; cin &amp;gt;&amp;gt; n; for (long long i = 1; i &amp;lt;= n; i++) { if (n % i == 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } } 這個方法雖然確實可以求出所有因數，但效率不夠好，考慮 $n$ 的因數都不會超過 $\sqrt{n}$，所以我們只需要枚舉到 $\sqrt{n}$ 即可，時間複雜度 $O(log\ n)$。
1 2 3 4 5 6 7 8 9 10 long long n; cin &amp;gt;&amp;gt; n; for (long long i = 1; i * i &amp;lt;= n; i++) { if (n % i == 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; if (i * i !</description></item><item><title>算法筆記-目錄</title><link>/posts/algo-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/algo-index/</guid><description> 時間複雜度概述 速度優化 排序 基礎資料結構 枚舉與二分搜尋 群論 數論 初階資料結構</description></item><item><title>算法筆記-群論</title><link>/posts/1/algo-group-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-group-theory/</guid><description>算法筆記目錄 群 有一個集合 $G$ 和一個二元運算子 $\cdot$，滿足以下條件，就稱 $(G,\cdot)$ 構成一個群：
封閉性 對於 $G$ 中的任意兩個元素 $a,b$，都有 $a\cdot b\in G$。 結合性 對於 $G$ 中的任意三個元素 $a,b,c$，都有 $a\cdot (b\cdot c)=(a\cdot b)\cdot c$。 單位元 對於 $G$ 中的任意元素 $a$，都有存在一個元素 $e$，使得 $a\cdot e=a=e\cdot a$。 逆元 對於 $G$ 中的任意元素 $a$，都有存在一個元素 $a^{-1}$，使得 $a\cdot a^{-1}=a^{-1}\cdot a=e$。 以加法為例，$a,b,c \in \mathbb{Z} $，$a+b+c$ 滿足上述條件，因此 $(\mathbb{Z},+)$ 構成一個群。
而因為 $+$ 滿足結合性，所以我們在做運算時不需要加括號，如果 $+$ 運算都與同一元素有關，可以變成乘法，$a+a+a=3a$
注意到群沒有必要滿足交換性，而如果群滿足交換性，則稱為交換群或阿貝爾群。
加法的逆元是負號，乘法的逆元是倒數。
如果 $G$ 中存在一個元素 $g$ 使得對 $G$ 中的任意元素 $a$ 都有 $a = g^n $，則稱 $(G,\cdot)$ 為循環群，也說 $G$ 由 $g$ 生成、$g$ 是 $G$ 的生成元，記作 $G = \langle g \rangle$，其中 $\langle g \rangle$ 稱為 $g$ 的生成集合(Span)。</description></item><item><title>線性代數筆記-消去法</title><link>/posts/LinearAlgebra/linear-elimination-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/LinearAlgebra/linear-elimination-methods/</guid><description>線性代數筆記-目錄
上一篇-線性方程系統簡介
高斯消去法(Gaussian elimination) 梯形(Echelon form) 如果有以下性質，稱為簡化列梯形(reduced row-echeleon form)： 若該列並非全為 $0$，則該列第一個非零元素為 $1$(leading 1)。 若該列全為 $0$，則必須被放在矩陣的最下方。 對於連續兩個非零列，較低列的 leading 1 必須在較高列的 leading 1 的右邊。 每一行除了 leading 1 之外，其餘元素皆為 $0$。 如果只滿足前三項，稱為列梯形(row-echeleon form)。 簡化列梯形有列梯形的性質，但不一定相反。 以下為簡化列梯形的例子：
$ \begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} $ $ \begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; a \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; b \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; c \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \end{bmatrix} $</description></item><item><title>線性代數筆記-目錄</title><link>/posts/LinearAlgebra/linear-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/LinearAlgebra/linear-index/</guid><description> 線性方程系統簡介 消去法 矩陣與矩陣運算</description></item><item><title>線性代數筆記-矩陣與矩陣運算</title><link>/posts/LinearAlgebra/linear-matrix-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/LinearAlgebra/linear-matrix-operations/</guid><description>線性代數筆記-目錄
上一篇-消去法
矩陣與矩陣運算(Matrices and Matrix Operations) 定義與表示法 矩陣是一堆數字的矩形陣列，陣列中的數字稱為矩陣的元素(entry)。 一個 $m \times n$ 的矩陣，可表示為 $A = \begin{bmatrix} a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \cdots &amp;amp; a_{mn} \end{bmatrix}$。 也可寫成 $[a_{ij}]_{m \times n}$。 $a_{ij}$ 表為矩陣 $A$ 的第 $i$ 列第 $j$ 行的元素。 加減法 如果矩陣大小相同，則可進行加減法，將對應位置的元素相加減。 乘法 如果是純量乘上矩陣，則將矩陣中的每個元素乘上純量。 如果是 $A$ 是 $m \times r$ 矩陣，$B$ 是 $r \times n$ 矩陣，則 $AB$ 是 $m \times n$ 矩陣，$AB$ 的第 $i$ 列第 $j$ 行的元素為 $ \sum_{k=1}^r a_{ik}b_{kj}$。 換句話說， $AB$ 的第 $j$ 行 $ = A $ [ $B$ 的第 $j$ 行]， $AB$ 的第 $i$ 列 $ = $ [ $A$ 的第 $i$ 列] $B$。 如果 $A$ 與 $B$ 的大小不是如同 $m \times r$ 與 $r \times n $ 的形式，則$AB$不存在。 線性系統的矩陣形式 $$\begin{array}{} a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1 \\ a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2 \\ \vdots \\ a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n = b_m\end{array}$$</description></item><item><title>線性代數筆記-線性方程系統簡介</title><link>/posts/LinearAlgebra/linear-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/LinearAlgebra/linear-intro/</guid><description>線性代數筆記-目錄
注意：以下所有行(columns)、列(rows)的定義皆以台灣的表示法為主，即行為直向，列為橫向
線性方程式 線性方程式 在二維直角座標系中，一個直線方程式可表示為 $ax+by=c$ ($a$, $b$ 不全為 $0$)
而在三維直角座標系中，一個平面方程式可表示為 $ax+by+cz=d$ ($a$, $b$, $c$ 不全為 $0$)
所以我們可以將線性方程式一般化，為了表示 $n$ 維 ($n$ 個變數) 的線性方程式，
將 $n$ 個變數分別表示為 $x_1, x_2, \cdots, x_n$，並將 $n$ 個係數分別表示為 $a_1, a_2, \cdots, a_n$，
則 $n$ 維線性方程式可表示為 $a_1x_1+a_2x_2+\cdots+a_nx_n=c$ ($a_1, a_2, \cdots, a_n$ 不全為 $0$)
或是 $ \sum^n_{i=1} a_i x_i = c$。
如果 $c$ 為 $0$，$ \sum^n_{i=1} a_i x_i = 0$，稱為 $x_1, x_2, \cdots, x_n$ 的齊次線性方程式。
線性方程系統 線性方程系統 有限個數的線性方程式集合，稱為線性方程系統(system of linear equations)或線性系統(linear system)。</description></item><item><title>資源</title><link>/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/resources/</guid><description> C++語法筆記 算法筆記 線性代數筆記 解題系統：
TIOJ CSES ZeroJudge Codeforces Uva 洛谷</description></item></channel></rss>