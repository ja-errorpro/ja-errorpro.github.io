<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ErrorPro</title><link>/</link><description>Recent content on ErrorPro</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>大學面試心得</title><link>/posts/2022/college_interview/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>/posts/2022/college_interview/</guid><description>申請入學(新課綱第一屆白老鼠) 身為2003/9月出生的我，變成教育部爆改課綱的頭一批白老鼠orz&amp;hellip;，可謂生於SARS，死於武漢！
以為今年數學會比110簡單，結果更難😠，我的學測直接燒到只剩43級分。
聽到這成績後我還是硬著頭皮把六個志願全都填電資/資工，
以下是我的一階正取校系以及二階面試狀況：
中原資工 - 疫情取消面試 中原資電不分系 - 疫情取消面試 逢甲資電不分系 - 521面試結束 元智資工 - 無面試 東海資工 - 522面試結束 哭啊只剩兩間面試，飯店都訂好了，直接噴掉1000
面試過程 逢甲資電不分系: 印象不錯，有熱情的學長姊(?，進去前會一直跟我們聊天(降低緊張感？
而且教授非常友善、和藹(幸運遇到白臉)~ 聽說另一間試場是黑臉教授
面試方式是一次六個人對三位教授，大概是這樣坐的：
教授 教授 教授
------長桌------
1(沒來) 2 3 4 5 我(6) 門
一開始教授讓我們輪流自我介紹，
而當右邊的教授聽到我參加APCS跟能競就問學過什麼語言，然後從我開始倒序輪流回答(我忘了講資奧初選被旁邊講走orz&amp;hellip;。
接著教授就問還有什麼問題
我問了有關往國外發展的條件，然後其他人也都問一問時間就到了。
整場就像是跟教授在聊天而已，真的不用太緊張，
第一天面試感覺非常好，希望第二天東海也能順利~
東海資工資電組: 一人對三個教授，而且也非常友善不用緊張
首先自我介紹，然後
教授(簡稱P): 你的經歷滿豐富的，分享一件你印象深刻的歷程跟收穫
我說了Farmbot(點我查看)的事
P: 你APCS考得不錯為什麼不填APCS組
我: 我認為APCS就是測驗自己的程式能力，沒有把他當我的入學管道
P: 我覺得你備審用Linux介面當封面的想法很有創意，而且你也有提到之前參加我們學校的AI營隊&amp;hellip;
^當事封面
P: 你還有報哪些科系，如果都上會選哪間
我回答比較保守，把每間優點都講出來後說再考慮
P: 好那你再好好考慮
P: 你比較喜歡資訊還電機
我: 資訊
P: 還有什麼想問的</description></item><item><title>【TIOJ】1903-你的笑容由我來守護-EXTREME</title><link>/posts/2022/tioj1903/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>/posts/2022/tioj1903/</guid><description>題目： 給一張$N$個點的無向圖，一開始有$M$條邊。 接著$Q$個操作，有以下兩種：
增加一條連著$A_i$、$B_i$的邊。 刪除一條連著$A_i$、$B_i$的邊(保證這條邊存在)。 每次操作完後輸出當前連通塊數量。
$1 \le N \le 5e5$ $M+Q \le 5e5$ $0 \le A_i,B_i \le N-1$ $A_i \neq B_i$ 輸入： 第一行有一個數字T代表測資筆數。
每筆測資第1行有3個整數N、M、Q。
接下來M行每行兩個整數Ai、Bi，代表Ai和Bi這兩個人目標相同。
接下來Q行，每行有一個字元 c 和兩個整數Ai、Bi，代表修改一個紀錄。
如果 c 是 N，代表增加一筆 Ai、Bi 兩人目標相同的紀錄；
如果 c 是 D，代表要刪除一筆 Ai、Bi 目標相同的紀錄，所有刪除都是合法的。
輸出： 對於每筆測資的Q筆修改，每次修改完輸出一行代表連通塊數量。
Ex 1 Input: 2 3 0 3 N 0 1 N 1 2 N 2 1 3 3 3 0 1 1 2 2 1 D 2 1 D 0 1 D 2 1 Ex 1 Output: 2 1 1 1 2 3 題解： 動態維護連通塊數量可以使用並查集(DSU)，但多了刪除的操作。</description></item><item><title>【CTF-WriteUp】EasyCTF-adder</title><link>/posts/2022/ctf_easyctf_adder/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><guid>/posts/2022/ctf_easyctf_adder/</guid><description>題目：
給你一個加法程式，找出Flag adder
概念： 反編譯 題解 在linux執行程式，看到要你輸入三個數，先隨意輸入，發現輸出nope。
開啟反編譯工具Ghidra對檔案反編譯，發現在main函式中的flag前綴，
而只要讓該行上面的if條件成立應該就能得到flag，顯然我們只要輸入三個數讓他加起來等於 0x539 即可。
透過簡單的進位換算，得$539_{16}\ =\ 1337_{10}$
開啟程式輸入1337 0 0 就可以拿到flag了~</description></item><item><title>網站搬家~</title><link>/posts/2022/newborn/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/newborn/</guid><description>我把網站從Jekyll改到Hugo了 因為111學測已經很久沒更新了，今天終於把網站搬遷成功，整個網站比以前看起來更舒服~
Hugo比起Jekyll更容易客製化，可以使用更多插件，之後有空就把留言系統加一加ㄅ~~</description></item><item><title>自架CodeServer，實現隨時隨地都能寫程式</title><link>/posts/2022/codeserver/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/codeserver/</guid><description>最近架了一台CodeServer，那是一個具有VSCode的伺服器平台，要他支援什麼語言照著一般設定VSC2方式就行~
先備條件： 會用Windows跟Ubuntu Docker以及容器的基礎操作 參考資源： codercom/Code-server
本文所用配備及版本： 物理機環境： Windows 11 Pro 21H2 Code Server版本： v4.0.2 步驟 (這裡省略前面Docker的安裝步驟)
先開一個資料夾名為CodeServer，這是伺服器的根目錄 新增一個檔案，檔名為docker-compose.yml 編輯檔案，貼上這些： 1version: &amp;#34;2.1&amp;#34; 2services: 3 code-server: 4 image: codercom/code-server 5 container_name: code-server 6 environment: 7 - TZ=ASIA/TAIPEI 8 - PASSWORD=&amp;lt;設定進入伺服器的密碼&amp;gt; 9 - SUDO_PASSWORD=&amp;lt;設定Root權限的密碼&amp;gt; 10 volumes: 11 - ./appdata/code-server/project:/home/coder/project 12 - ./appdata/code-server/.local:/home/coder/.local 13 ports: 14 - &amp;lt;PORT&amp;gt;:8080 15 restart: always (1) version: 不用動他
(2) image: 指定目標映像，Docker會試著到上面給的網站找尋映像檔</description></item><item><title>About</title><link>/about/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>/about/</guid><description>我是誰 黃乙家 weak
來自雲林的普通人
DP好難哦
IG: cannot.load_connection.refused</description></item><item><title>區間詢問比K小的數量</title><link>/posts/2021/mergesorttree/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mergesorttree/</guid><description>今天是資訊能競校內初選，沒把經典題做出來真的很可惜。
所以來刻點線段樹緩下心情(?
順便測試一下在網站中使用 $ \LaTeX $
先要基礎： 線段樹、二分搜、排序
合併排序樹 合併排序樹是一種線段樹，節點上都是一個向量(Vector)， 比如節點的範圍是[l,r]，則節點上向量就是已排序過的array[l~r]。 題目： 輸入 $n$ 個數到陣列 $A$，然後輸入一個 $q$ 代表詢問次數。
接著每次詢問有三個數 $l,r,k$ 代表詢問的區間$[l,r]$ 有幾個數比 $k$ 小。
其中，$ 1 \le n,q \le 2*10^5$，且陣列中沒有重複數字。
輸入： 首先輸入一整數 $n$，
再來一行有$n$個數代表 $a_i(1 \le a_i \le 10^9)$。
接下來一行輸入整數$q$，
接著有 $q$ 行分別輸入 $l,r,k$。
輸出： 一個整數代表在 $[l,r]$ 區間內有幾個數比 $k$ 小。
Ex 1 Input: 10 5 2 1 9 10 4 8 7 6 3 5 1 10 6 4 8 7 6 9 4 1 8 5 2 7 10 Ex 1 Output: 5 1 0 3 5 Note: 第一個詢問區間 $[1,10]，k=6$，其中比k小的元素有:$ {5,2,1,4,3} $，共$5$個。</description></item><item><title>103年彰雲嘉P5 - Infix to Postfix</title><link>/posts/2021/mtwcp103_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp103_5/</guid><description>題目： 一般我們在表示運算式時，是使用中序式，是將運算子放在兩運算元中間， 比如 (A+B)*(C+D)。而在電腦中，需要將中序式轉成後序式以方便運算。 (A+B)*(C+D)的後序式為 AB+CD+*； A*(B+C)-D*E+F 的後序式為 ABC+*DE*-F+ 。 請寫一程式將中序式轉成後序式。 輸入： 輸入一個中序運算式，其中運算元為A~Z等26個單一字母表示，運算子只包含+、-、*、/。 運算式中可有任意多個括號，且保證輸入的式子合法。 輸出： 輸出後序式。 Ex 1 Input: 中置式: (A+B*(C-D)+E)* ((F+G)/(H*I)+J) Ex 1 Output: 後置式: ABCD-*+E+FG+HI*/J+* 題解： 需要注意的是四則運算的優先序(括號先算，由左到右，先乘除，後加減)。
這題是非常經典的堆疊資料結構應用題，用 getline 輸入，遇到運算子就加入堆疊，
先看括號，然後看加減乘除，如果遇到 ) 的話，就把堆疊的運算子都輸出直到碰到 ( 為止。
而運算元則直接輸出就行。
(我的編譯器因為格式問題輸出不了中文&amp;hellip;反正程式碼對就好)
這問題可以再延伸，比如以中序式進行四則運算輸出結果，
跟這題做法很像只要把中序轉成後序然後讀一遍，
遇到運算子就把前面讀到的數字做運算後放入堆疊，注意運算子可能有多位數。
補充：這種需要stack的題目通常能用遞迴完成，因為遞迴本身就是一種堆疊。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>107年彰雲嘉p3 - GCD &amp; LCM</title><link>/posts/2021/mtwcp107_3/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_3/</guid><description>題目： 給你一堆數字(&amp;gt;=0)，求他們的GCD(最大公因數)與LCM(最小公倍數) 輸入： 一堆數字以空格分開，最後以0結束 輸出： 所有數字(除了0以外)的GCD跟LCM，以空格分開 Ex 1 Input: 10 20 30 0 Ex 2 Input: 3 5 7 9 12 0 Ex 3 Input: 100 100 200 0 Ex 1 Output: 10 60 Ex 2 Output: 1 1260 Ex 3 Output: 100 200 題解： 就是一題簡單的數論題， 可以根據歐幾里得算法 gcd(a,b-a) = gcd(a,b mod a), gcd(a,0) = |a| (輾轉相除)來求GCD， 那LCM要怎麼求？我們知道 a | (a*b) 且 b | (a*b) (a*b必為ab公倍數) 如果要得到最小公倍數，只要除以gcd(a,b)就行。</description></item><item><title>107年彰雲嘉P6 - 統一發票對獎程式</title><link>/posts/2021/mtwcp107_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_6/</guid><description>題目： Ex 1 Input: 73372972 22315462 91903003 16228722 03270598 163 983 814 73372971 22315461 91903001 16228722 13210598 03210163 0 Ex 1 Output: 201200 題解： 前三個獎直接判別，後面判別如果你用int，就 mod pow(10,i)；
如果你用字串，直接複製 string s1(s.begin()+i,s.end())。
這裡使用字串判別。
判定順序可以任意，總之記得符合條件就一定要break不然會多算。
增開六獎跟持有號碼數量雖然不一定，但他們長度都是固定的，
string直接s.size()，而int你可以透過除以1000 == 0? 判別。
這裡直接把六獎當增開六獎判定，反正結果一樣。
官方測資的獎金不會超過$2^{31}$，所以不會溢位。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.tie(0); 9#define GETOUT cout.</description></item><item><title>108年彰雲嘉上午P5 - 魔術三角形</title><link>/posts/2021/mtwcp108_1_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_5/</guid><description>題目： 魔術三角形是一個由1到9的數字所形成之三角形， 每邊由4個數字組成，邊與邊之間會有1個數字共用，而且每個邊 4個數字相加之總和是一樣的，舉例來說，下圖是一個魔術三角形，三個邊的數字和均為19。 我們以三角形最上面的數字7為起點，順時針方向列出所有9個數字來表示這個三角形， 表示為&amp;quot;781359264&amp;quot; (取自108年彰雲嘉資訊科能力競試上午場P5)
預先將下圖的三個藍色粗框部分填入數字，請填入其餘數字使其成為一個魔術三角形。 (取自108年彰雲嘉資訊科能力競試上午場P5)
輸入： 三個1~9之間的數代表依順時針填入藍色粗框的3個數字。 輸出： 將形成的魔術三角形之9個數字合併成一個十進位數字輸出，若存在多個答案 ，則輸出十進位數字最小者。若無法形成魔術三角形，則輸出1個0。 Ex 1 Input: 4 3 6 Ex 2 Input: 4 6 7 Ex 1 Output: 542937168 Ex 2 Output: 249561873 題解： 題目沒給時間限制，當然直接暴力做下去啊！
時間複雜度也只有O(6!) = O(720)，
所以也不會超過1秒
可使用next_permutation()這個函式，
他是用來枚舉排列的工具，既然是排列，
有學過排列組合都知道不重複排列數是P(n,n)
那時間複雜度就會是O(P(n,n))=O(n!)
如果遇到排列數很多的就還是別用了吧
記得在用這個函式時要先把要排的數組先排序好，
才能完整枚舉所有排列。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>108年彰雲嘉上午P6 - Knight Moves</title><link>/posts/2021/mtwcp108_1_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_6/</guid><description>題目： 西洋棋騎士/象棋的馬每步可以沿日字對角走到另一對角， 現在有一個X*Y的棋盤，左下角座標(0,0)，右下為(X-1,0) 棋子的起始點為(a,b)，請求出走到(c,d)的最小步數。 其中X,Y&amp;lt;=10000 輸入： 本題有多筆測資，第一行輸入N代表有幾筆測資 接下來每筆測資有一行， 依序以空格分開輸入6個正整數X, Y, a, b, c, d 輸出： 針對每筆測資依序輸出最短步數 Ex 1 Input: 2 10 10 3 4 7 6 10 10 3 4 9 9 Ex 1 Output: 2 5 題解： 如果還是不懂騎士走法可參考 維基百科
這題是非常經典的最短路問題，可使用BFS(廣度優先搜尋)解。
可以想像有一個確診武漢肺炎的同學坐在班上位置中間，
而病毒就從那位同學開始往旁邊擴散，
每過一天就一個確診，
最後全班都被感染病毒，
然後就能求哪位同學會在第幾天確診。
其原理是利用佇列(&amp;lt;queue&amp;gt;)，造訪所有圖上的位置，
並記錄從起點到每個位置一共走了多少步。
騎士走法是按照日字走的，因此可推論一個點會有八種走法
而步數就是上一個點的步數再+1
上程式碼(當然你可以用struct建立點佇列，就不用宣告那麼多queue跟陣列了)：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>108年彰雲嘉下午P10 - Huffman</title><link>/posts/2021/mtwcp108_2_10/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_2_10/</guid><description>題目： Huffman ： 維基百科
霍夫曼樹經常被用來作資料壓縮，將字串資料轉成霍夫曼碼以減少字串資料所佔的空間大小，其詳細作法如下： (1)字串中所有的字母元素都放在最底層的葉節點上，節點中的值為此字母的出現次數。 (2) 每次從尚無父節點的所有節點中，尋找值最小（出現次數最少）的兩個節點來建立霍夫曼樹， 產生其父節點的值為兩個節點值相加的和。最後只剩下根節點沒有父節點。 (3) 從根節點開始往下編碼，左分支為 0，右分支為 1，每個葉節點的字母元素會產生一個霍夫 曼碼（由 0 和 1 所組成），字母元素出現的頻率越高則霍夫曼碼越短。 我們這題需要計算一個字串轉成霍夫曼碼的壓縮率。假設有個字串&amp;quot;queue&amp;quot;，則此字串會佔5 bytes = 40bits空間， 轉成霍夫曼碼後應為&amp;quot;00011011&amp;quot;，只需要8個bits就可儲存，因此壓縮率為(40-8)/40 * 100% = 80%。 輸入： 輸入一列字串(長度最多100字元，且不含空格)。 輸出： 依序輸出此字串壓縮前的bit數、壓縮後的bit數、壓縮率百分比(格式為⌊n⌋%，即n向下取整)。 Ex 1 Input: queue Ex 2 Input: abadcafcabfdec Ex 3 Input: aaaaaaamcmhhhhhmkkkkkkkkmbbmdddddddmyymppppp Ex 4 Input: BCBBB Ex 1 Output: 40 8 80% Ex 2 Output: 112 35 68% Ex 3 Output: 352 132 62% Ex 4 Output: 40 5 87% 題解： 題目沒說字串中大小寫是否要算成同一字母，因此先視為不同的來處理。</description></item><item><title>Farmbot歷程</title><link>/posts/2021/farmbot/</link><pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate><guid>/posts/2021/farmbot/</guid><description>Farmbot
(本頁面在舊版網站發布，會有不少顯示問題)
FBTUG共筆資料
什麼是Farmbot? 一個機器人開放式系統，可通過土地種植，澆水，土壤測試和除草為所有需要耕種小土地跟想種糧食的人提供幫助
使用Raspberry Pi(樹莓派)，Arduino以及其他優良組件
1.碳足跡 製造 目前看重環保議題,Farmbot使用最普遍的材料:
材料 用途 重量(kg) kg CO2/物料 kg CO2(kg) 鋁 擠壓板 9.5 8.24 78.3 不鏽鋼 硬件，軸承，驅動軸，絲槓 1.4 6.15 8.6 塑料 拖鏈，3D列印[CAD]，輪子，電子設備，管材，電路板 2.8 2.53 7.1 銅 電，佈線，電動機繞組 0.3 2.60 0.8 橡膠 皮帶，電線，墊片 0.2 3.18 0.6 合計 95.4 每生產Farmbot排放的理論量約 95.</description></item><item><title>Python遊戲設計</title><link>/posts/2021/pythongame/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>/posts/2021/pythongame/</guid><description>FOR Python遊戲設計 檔案庫: Here
Python程式列表(全自寫): LIST
Cocos2d: Docs
第一堂: IDE: pycharm CE, Module: cocos2d 彭彭-Python程式設計入門
Colab
CBE30338
記得寫程式可放個小抄在旁邊&amp;hellip;
有問題請點這個
作業: 遊玩CodeCombat
第二堂 安裝Pycharm : Pycharm
Community版為開源,免費 / Professional為完整版(30天免費試用)
需要先安裝Python (Ver. &amp;gt;3.7),Windows:可在Microsoft市集搜尋Python / MacOS可在官網上下載 / Linux有些版本已預安裝,安裝方式: ($ apt update &amp;amp;&amp;amp; apt install python3)
安裝方式: Here
設定: here
安裝Cocos2d: Files&amp;gt;Setting&amp;gt;Project: Inter..&amp;gt;(+)&amp;gt;搜尋cocos2d&amp;gt;安裝
學程式的技巧: 先抄再讀 不懂可Google
Vim: 分為命令模式,插入模式,底線命令模式,視覺模式
命令模式: 為預設模式,在任何模式中按下Esc即可到此模式,可按下某些鍵來切換模式
插入模式: 切換方式:在命令模式中按下i,a,o等按鍵,可在游標位置插入需要的文字
底線命令模式: 切換方式:按下:,可輸入指令操作內容,
離開: :q
強制離開: :q!
存檔不離開: :w</description></item><item><title>C++筆記-語法</title><link>/posts/1/cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/cpp/</guid><description>*所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主
程式碼運作原理 我們知道其實電腦只懂0與1，因此想跟電腦溝通就需要透過一些轉譯，
在人類的世界中所使用的語言叫高階語言，而只由0與1數字組成的語言稱為機器語言，我們很難看懂，
要將高階語言轉成機器語言，就需要藉由編譯器與組譯器的幫忙，編譯器可以幫我們把程式碼轉成所謂的組合語言，此時階段
就會有很多人開始看不懂了，當然如果有學過還是能稍微看懂，但組合語言經過組譯器就會變成0跟1，只有電腦才看得懂。
基礎C++模板 附上STL標頭檔：
1#include&amp;lt;bits/stdc++.h&amp;gt;注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個
這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 &amp;lt;algorithm&amp;gt; 裡的__gcd(計算最大公因數)
不過有些編譯器不包含這個標頭檔，可以自己Google找到對應的解決方法。
有時候看別人的Code還會看到一個標頭檔 &amp;lt;bits/extc++.h&amp;gt; ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。
為了方便，會在下面定義名稱空間 using namespace std; ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣在做像是輸入輸出(cin、cout)等操作時 不需要在每個句子前面加上 std:: 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。 打個比喻，如果說標頭檔是圖書館，那std就是你想找的書。
而每個程式都會需要一個叫做main的主函式，這個函式就是整個程式的起點跟終點：
1int main(){ 2 return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。 3} 在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。
注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在C++，&amp;ldquo;引入標頭檔&amp;quot;這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。
總結程式碼(模板)： 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main(){ 4 cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 你會看到電腦跟你說Hello World 5 return 0; 6} 註解 在上面兩個程式碼中，會看到裡面寫了 // 後面接上說明，稱為&amp;quot;註解&amp;rdquo;，註解的內容不會被編譯器讀取，註解有兩種模式： 單行註解及多行註解，在C++裡的語法是這樣的
1// 這是單行註解 2 3/* 4這是多行註解 5*/ 之後會有很多透過註解說明程式碼的部分。</description></item><item><title>留言區</title><link>/comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/comment/</guid><description> initComments({ node: document.getElementById("comment-section"), defaultHomeserverUrl: "https://matrix.cactus.chat:8448", serverName: "cactus.chat", siteName: "errorpro", commentSectionId: "website" })</description></item><item><title>算法筆記-基本/初階資料結構</title><link>/posts/1/algo-basic-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-basic-structure/</guid><description>算法筆記目錄 基礎資料結構 我們程式想儲存東西有很多種方式，而資料結構就像一種容器，
可以儲存或拿取需要的東西，每種資料結構都有不同的複雜度，
如果用得好，效率就會高。
以下都是最基本的資料結構
1.Vector - 向量 in &amp;lt;vector&amp;gt; 1vector&amp;lt;int&amp;gt; v; 向量可當成陣列來用，應該說它就是更強的陣列，而且易維護。
比起原本陣列，它可以自動擴大容量，
能用的空間也比陣列還多。但要注意的是，如果使用operator[]存取了未配置的記憶體位置，
會導致Segmentation Fault。
以下為vector的功能： -- vector[n] 存取索引值為n的元素 -- vector.at(n) 存取索引值為n的元素(較安全) -- vector.begin() 回傳指向vector第一個元素的疊代器 -- vector.end() 回傳指向vector最後一個元素再下一個的疊代器 -- vector.front() 回傳vector[0] -- vector.back() 回傳vector最後一個元素的值 -- vector.size() 回傳目前vector儲存了多少元素 -- vector.resize(n) 修改vector大小 -- vector.capacity() 存取可容納最大個數 -- vector.empty() 回傳布林值表示vector是不是空的 -- vector.reserve(n) 配置更多記憶體以容納更多元素 -- vector.push_back(n) 把n放到vector最尾端 -- vector.pop_back() 把vector最尾端元素取出 -- vector.insert(it,n) 在疊代器it後插入元素n -- vector.erase(it,(it2)) 刪除疊代器it~it2的元素 -- vector.clear() 刪除所有元素 -- vector.</description></item><item><title>算法筆記-常數優化</title><link>/posts/1/algo-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-io/</guid><description> 算法筆記目錄 編譯器優化 我們的程式變成執行檔時需要經過一連串的轉譯與運算，
如果改變編譯器的編譯模式，或者改變寫程式的習慣，有可能會讓效率變更高。
一般的Judge編譯器模式都是O2，是個比較安全的運算方式。
但其實我們可以在程式中再加入一些指令，改變編譯器的運算方式。
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2//以較不安全的運算來編譯程式 3#pragma loop_opt(on) 4//迴圈優化 5#pragma comment(linker,&amp;#34;/stack:200000000&amp;#34;) 6//更改最大堆疊數 以上是我常用的編譯器優化指令，
請注意不是所有OJ都支援pragma優化。
I/O優化 當我們比較cout、cin與printf、scanf時，會發現後者比前者快非常多。
這是因為每次在輸入輸出前，程式會將資料放進一個緩衝區(內存)，然後再從內存裡拿出。
我們應該減少拿取的動作，因為這非常耗時。
如果做過CF互動題，會發現題目會要求在輸出後加上cout.flush()，就是要把資料強制輸出，
否則它可能要等到程式結束後才輸出。
cin，它的原理其實是讀取鍵盤輸入的字，再輸出給使用者看打了什麼，
這就讓拿取的動作暴增了，解決方法是加上 cin.tie(0);
讓內存強制釋放掉。
C++有兩種輸出輸入，分別是stdio與iostream，而程式可能會搞混而發生問題
，使得效率變差，這時就加上 ios_base::sync_with_stdio(false); 就解決了
加上這行後，之後的輸入輸出就是選(cin,cout)或(scanf,printf)其中一個，
絕對不要再混用。
C++的換行可以是endl或&amp;rsquo;\n&amp;rsquo;，而其實 cout &amp;lt;&amp;lt; endl 相當於 cout &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; flush
也就是它順便把內存清空了，做了多餘的動作。
之後記得要換行的話就用&amp;rsquo;\n&amp;rsquo;別再用endl了。 或放個 #define endl '\n'</description></item><item><title>算法筆記-排序</title><link>/posts/1/algo-sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-sorting/</guid><description>算法筆記目錄 排序 排序是將一串資料依優先度排列，通常是遞增、遞減、字典序排列，
可以自訂順序，這裡直接使用快速排序法，後面分治會提到合併排序，
快慢隨題目而變動。
我們學校會學到最經典的氣泡排序法，其實是個很不好的排序法，
它最差情況的時間複雜度會炸到$O(n^2)$。
在C++，有函數 sort() 可以直接排序，
以遞增排序為例，原理是先從資料群選一個基準點，
然後從資料兩邊往中間搜，若右邊比基準點小且左邊比基準點大，就將左右邊互換，
直到左右邊相遇，將相遇的點與基準點互換。
複雜度是$O(nlogn)$。
想體驗sort()的力量，我們用random_shuffle()這個函數來打亂區間。
1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3signed main(){ 4 vector&amp;lt;int&amp;gt; a={9,8,7,6,5,4,3,2,1}; 5 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 6 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 7 8 random_shuffle(a.begin(),a.end()); 9 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 10 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 11 12 sort(a.begin(),a.end()); 13 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 14 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 15 16 return 0; 17} sort()預設是遞增排列，如果想遞減排列，可以在第三個引數加上 less&amp;lt;型態&amp;gt;()，</description></item><item><title>算法筆記-時間複雜度概述</title><link>/posts/1/algo-runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-runtime/</guid><description>算法筆記目錄 時間複雜度在競程中是個非常重要且最基本的工具，
係用於估算程式執行N次，大概需要花多久時間。
我們在程式中做的任何事情可能都需要花費1單位時間，
比如五則運算、條件判斷、變數存賦等。
而我們通常會使用函式$O(Big-O)$ 來表示程式的複雜度。
對於$O()$，有以下定義：
$$ Def:\
\qquad If\ f(x) = O(g(x)),\ ∃M,x_0 &amp;gt; 0,\ such \ that \ ∀x&amp;gt;=x_0,then \ |f(x)| &amp;lt;= M|g(x)| $$
為什麼我們需要估時間複雜度？
因為我們在寫程式追求的是速度！當你的演算法太慢(時間複雜度太大)時，
就算結果是對的，但你會在Online Judge上或APCS得到一個TLE(Time Limit Exceeded)，
即若將測資丟到你的程式，會超出該題目所規定的執行時間。
要如何估自己的程式會跑幾秒？
通常，Judge的執行速度大約是1e8筆/秒，因此只要將題目的範圍限制代入所估複雜度，
然後除以1e8，就能大概知道自己程式會不會TLE了。
常見的複雜度有： $1,n,n^2,n^3,nlogn,2^n$。 而log通常以2為底但我們不太會去明指以誰為底。
以下是複雜度計算的原則：
&amp;ndash; 1.常數倍數不計( $O(2n) = O(n) = O(3n)$ )。
&amp;ndash; 2.若將程式分成兩段複雜度為$O(f(n)),\ O(g(n))$,總複雜度就取複雜度比較大的那段。
即$O(f(n)+g(n)) = O(f(n)) &amp;gt; O(g(n)) ? O(f(n)) : O(g(n))$
&amp;ndash; 3.若有一段程式複雜度為$O(f(n))$執行$g(n)$次，總複雜度是$O(f(n)*g(n))$。</description></item><item><title>算法筆記-目錄</title><link>/posts/1/algo-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-index/</guid><description> 時間複雜度概述 基礎/初階資料結構 速度優化 排序</description></item><item><title>算法筆記-進階資料結構-線段樹</title><link>/posts/1/algo-segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-segtree/</guid><description>回到算法筆記-進階資料結構
線段樹 Segment Tree是一種二元樹，適合解決RMQ問題(查詢區間極值)、區間和， 適合用於單點修改、區間修改。
成功實現Sparse Table做不到的事。
每個節點可以存一種區間的數據(比如區間和)，
根節點存[1,n]的數據，每個左子節點編號是index*2，右邊為index*2+1，
左邊紀錄[l,(l+r)/2)，右邊紀錄[(l+r)/2+1,r]。
通常，線段樹會開4倍大
1int T[4*N],a[N]; // int T[N&amp;lt;&amp;lt;2]; 建立線段樹，若l==r，此節點即a[l] 子樹建完後就把資料合併
1void build(int l,int r,int index){ 2 if(l==r){ 3 T[l] = a[l]; 4 } 5 else{ 6 int mid = l+(r-l)/2; // 避免 (l+r)/2 溢位 7 build(index*2,l,mid); // build(index&amp;lt;&amp;lt;1,l,mid); 8 build(index*2+1,mid+1,r); 9 T[index] = T[index*2] + T[index*2+1] ; 10 } 11} 詢問區間(ql,qr:要查的區間 l,r:此節點儲存的左右界) 1int query(int ql,int qr,int l,int r,int index){ 2 if(ql&amp;lt;=l &amp;amp;&amp;amp; qr&amp;gt;=r) return T[index]; 3 int mid = l+(r-l)/2; 4 int rt=0; 5 if(ql&amp;gt;mid) rt+=query(ql,qr,mid+1,r,index*2+1); 6 if(qr&amp;lt;=mid) rt+=query(ql,qr,l,mid,index*2); 7 return rt; 8} 單點修改 1void modify(int l,int r,int pos,int index,int val){ 2 if(l==r){ 3 T[index] = val;return; 4 } 5 int mid = l+(r-l)/2; 6 if(pos&amp;lt;=mid) modify(l,mid,pos,index*2,val); 7 else modify(mid+1,r,pos,index*2+1,val); 8 T[index] = T[index*2]+T[index*2+1]; 9} 懶人標記 如果想在[l,r]中的所有元素加值怎麼辦？ 不可能一個一個呼叫modify吧。</description></item><item><title>資源</title><link>/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/resources/</guid><description> C++語法筆記 算法筆記 解題系統：
TIOJ
CSES
ZeroJudge
Codeforces
Uva
洛谷
自己亂搞的OJ</description></item></channel></rss>