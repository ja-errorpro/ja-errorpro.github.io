<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ErrorPro</title><link>/</link><description>Recent content on ErrorPro</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>網站搬家~</title><link>/posts/2022/newborn/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/newborn/</guid><description>我把網站從Jekyll改到Hugo了 因為111學測已經很久沒更新了，今天終於把網站搬遷成功，整個網站比以前看起來更舒服~
Hugo比起Jekyll更容易客製化，可以使用更多插件，之後有空就把留言系統加一加ㄅ~~</description></item><item><title>自架CodeServer，實現隨時隨地都能寫程式</title><link>/posts/2022/codeserver/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/2022/codeserver/</guid><description>最近架了一台CodeServer，那是一個具有VSCode的伺服器平台，要他支援什麼語言照著一般設定VSC2方式就行~
先備條件： 會用Windows跟Ubuntu Docker以及容器的基礎操作 參考資源： codercom/Code-server
本文所用配備及版本： 物理機環境： Windows 11 Pro 21H2 Code Server版本： v4.0.2 步驟 (這裡省略前面Docker的安裝步驟)
先開一個資料夾名為CodeServer，這是伺服器的根目錄 新增一個檔案，檔名為docker-compose.yml 編輯檔案，貼上這些： 1version: &amp;#34;2.1&amp;#34; 2services: 3 code-server: 4 image: codercom/code-server 5 container_name: code-server 6 environment: 7 - TZ=ASIA/TAIPEI 8 - PASSWORD=&amp;lt;設定進入伺服器的密碼&amp;gt; 9 - SUDO_PASSWORD=&amp;lt;設定Root權限的密碼&amp;gt; 10 volumes: 11 - ./appdata/code-server/project:/home/coder/project 12 - ./appdata/code-server/.local:/home/coder/.local 13 ports: 14 - &amp;lt;PORT&amp;gt;:8080 15 restart: always (1) version: 不用動他
(2) image: 指定目標映像，Docker會試著到上面給的網站找尋映像檔</description></item><item><title>About</title><link>/about/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>/about/</guid><description>我是誰 黃乙家
我站在雲林，正心高中生
很愛亂玩資訊(黑)科技
IG: cannot.load_connection.refused</description></item><item><title>區間詢問比K小的數量</title><link>/posts/2021/mergesorttree/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mergesorttree/</guid><description>今天是資訊能競校內初選，沒把經典題做出來真的很可惜。
所以來刻點線段樹緩下心情(?
順便測試一下在網站中使用 $ \LaTeX $
先要基礎： 線段樹、二分搜、排序
合併排序樹 合併排序樹是一種線段樹，節點上都是一個向量(Vector)， 比如節點的範圍是[l,r]，則節點上向量就是已排序過的array[l~r]。 題目： 輸入 $n$ 個數到陣列 $A$，然後輸入一個 $q$ 代表詢問次數。
接著每次詢問有三個數 $l,r,k$ 代表詢問的區間$[l,r]$ 有幾個數比 $k$ 小。
其中，$ 1 \le n,q \le 2*10^5$，且陣列中沒有重複數字。
輸入： 首先輸入一整數 $n$，
再來一行有$n$個數代表 $a_i(1 \le a_i \le 10^9)$。
接下來一行輸入整數$q$，
接著有 $q$ 行分別輸入 $l,r,k$。
輸出： 一個整數代表在 $[l,r]$ 區間內有幾個數比 $k$ 小。
Ex 1 Input: 10 5 2 1 9 10 4 8 7 6 3 5 1 10 6 4 8 7 6 9 4 1 8 5 2 7 10 Ex 1 Output: 5 1 0 3 5 Note: 第一個詢問區間 $[1,10]，k=6$，其中比k小的元素有:$ {5,2,1,4,3} $，共$5$個。</description></item><item><title>103年彰雲嘉P5 - Infix to Postfix</title><link>/posts/2021/mtwcp103_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp103_5/</guid><description>題目： 一般我們在表示運算式時，是使用中序式，是將運算子放在兩運算元中間， 比如 (A+B)*(C+D)。而在電腦中，需要將中序式轉成後序式以方便運算。 (A+B)*(C+D)的後序式為 AB+CD+*； A*(B+C)-D*E+F 的後序式為 ABC+*DE*-F+ 。 請寫一程式將中序式轉成後序式。 輸入： 輸入一個中序運算式，其中運算元為A~Z等26個單一字母表示，運算子只包含+、-、*、/。 運算式中可有任意多個括號，且保證輸入的式子合法。 輸出： 輸出後序式。 Ex 1 Input: 中置式: (A+B*(C-D)+E)* ((F+G)/(H*I)+J) Ex 1 Output: 後置式: ABCD-*+E+FG+HI*/J+* 題解： 需要注意的是四則運算的優先序(括號先算，由左到右，先乘除，後加減)。
這題是非常經典的堆疊資料結構應用題，用 getline 輸入，遇到運算子就加入堆疊，
先看括號，然後看加減乘除，如果遇到 ) 的話，就把堆疊的運算子都輸出直到碰到 ( 為止。
而運算元則直接輸出就行。
(我的編譯器因為格式問題輸出不了中文&amp;hellip;反正程式碼對就好)
這問題可以再延伸，比如以中序式進行四則運算輸出結果，
跟這題做法很像只要把中序轉成後序然後讀一遍，
遇到運算子就把前面讀到的數字做運算後放入堆疊，注意運算子可能有多位數。
補充：這種需要stack的題目通常能用遞迴完成，因為遞迴本身就是一種堆疊。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>107年彰雲嘉p3 - GCD &amp; LCM</title><link>/posts/2021/mtwcp107_3/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_3/</guid><description>題目： 給你一堆數字(&amp;gt;=0)，求他們的GCD(最大公因數)與LCM(最小公倍數) 輸入： 一堆數字以空格分開，最後以0結束 輸出： 所有數字(除了0以外)的GCD跟LCM，以空格分開 Ex 1 Input: 10 20 30 0 Ex 2 Input: 3 5 7 9 12 0 Ex 3 Input: 100 100 200 0 Ex 1 Output: 10 60 Ex 2 Output: 1 1260 Ex 3 Output: 100 200 題解： 就是一題簡單的數論題， 可以根據歐幾里得算法 gcd(a,b-a) = gcd(a,b mod a), gcd(a,0) = |a| (輾轉相除)來求GCD， 那LCM要怎麼求？我們知道 a | (a*b) 且 b | (a*b) (a*b必為ab公倍數) 如果要得到最小公倍數，只要除以gcd(a,b)就行。</description></item><item><title>107年彰雲嘉P6 - 統一發票對獎程式</title><link>/posts/2021/mtwcp107_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_6/</guid><description>題目： Ex 1 Input: 73372972 22315462 91903003 16228722 03270598 163 983 814 73372971 22315461 91903001 16228722 13210598 03210163 0 Ex 1 Output: 201200 題解： 前三個獎直接判別，後面判別如果你用int，就 mod pow(10,i)；
如果你用字串，直接複製 string s1(s.begin()+i,s.end())。
這裡使用字串判別。
判定順序可以任意，總之記得符合條件就一定要break不然會多算。
增開六獎跟持有號碼數量雖然不一定，但他們長度都是固定的，
string直接s.size()，而int你可以透過除以1000 == 0? 判別。
這裡直接把六獎當增開六獎判定，反正結果一樣。
官方測資的獎金不會超過$2^{31}$，所以不會溢位。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.tie(0); 9#define GETOUT cout.</description></item><item><title>108年彰雲嘉上午P5 - 魔術三角形</title><link>/posts/2021/mtwcp108_1_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_5/</guid><description>題目： 魔術三角形是一個由1到9的數字所形成之三角形， 每邊由4個數字組成，邊與邊之間會有1個數字共用，而且每個邊 4個數字相加之總和是一樣的，舉例來說，下圖是一個魔術三角形，三個邊的數字和均為19。 我們以三角形最上面的數字7為起點，順時針方向列出所有9個數字來表示這個三角形， 表示為&amp;quot;781359264&amp;quot; (取自108年彰雲嘉資訊科能力競試上午場P5)
預先將下圖的三個藍色粗框部分填入數字，請填入其餘數字使其成為一個魔術三角形。 (取自108年彰雲嘉資訊科能力競試上午場P5)
輸入： 三個1~9之間的數代表依順時針填入藍色粗框的3個數字。 輸出： 將形成的魔術三角形之9個數字合併成一個十進位數字輸出，若存在多個答案 ，則輸出十進位數字最小者。若無法形成魔術三角形，則輸出1個0。 Ex 1 Input: 4 3 6 Ex 2 Input: 4 6 7 Ex 1 Output: 542937168 Ex 2 Output: 249561873 題解： 題目沒給時間限制，當然直接暴力做下去啊！
時間複雜度也只有O(6!) = O(720)，
所以也不會超過1秒
可使用next_permutation()這個函式，
他是用來枚舉排列的工具，既然是排列，
有學過排列組合都知道不重複排列數是P(n,n)
那時間複雜度就會是O(P(n,n))=O(n!)
如果遇到排列數很多的就還是別用了吧
記得在用這個函式時要先把要排的數組先排序好，
才能完整枚舉所有排列。
上程式碼：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>108年彰雲嘉上午P6 - Knight Moves</title><link>/posts/2021/mtwcp108_1_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_6/</guid><description>題目： 西洋棋騎士/象棋的馬每步可以沿日字對角走到另一對角， 現在有一個X*Y的棋盤，左下角座標(0,0)，右下為(X-1,0) 棋子的起始點為(a,b)，請求出走到(c,d)的最小步數。 其中X,Y&amp;lt;=10000 輸入： 本題有多筆測資，第一行輸入N代表有幾筆測資 接下來每筆測資有一行， 依序以空格分開輸入6個正整數X, Y, a, b, c, d 輸出： 針對每筆測資依序輸出最短步數 Ex 1 Input: 2 10 10 3 4 7 6 10 10 3 4 9 9 Ex 1 Output: 2 5 題解： 如果還是不懂騎士走法可參考 維基百科
這題是非常經典的最短路問題，可使用BFS(廣度優先搜尋)解。
可以想像有一個確診武漢肺炎的同學坐在班上位置中間，
而病毒就從那位同學開始往旁邊擴散，
每過一天就一個確診，
最後全班都被感染病毒，
然後就能求哪位同學會在第幾天確診。
其原理是利用佇列(&amp;lt;queue&amp;gt;)，造訪所有圖上的位置，
並記錄從起點到每個位置一共走了多少步。
騎士走法是按照日字走的，因此可推論一個點會有八種走法
而步數就是上一個點的步數再+1
上程式碼(當然你可以用struct建立點佇列，就不用宣告那麼多queue跟陣列了)：
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2#pragma loop_opt(on) 3#include&amp;lt;bits/stdc++.h&amp;gt;4using namespace std; 5template&amp;lt;class T&amp;gt; long long Mod(T a,T b){return ((a%b)+b)%b;} 6#define endl &amp;#39;\n&amp;#39; 7#define ll long long 8#define IO ios_base::sync_with_stdio(0); cin.</description></item><item><title>108年彰雲嘉下午P10 - Huffman</title><link>/posts/2021/mtwcp108_2_10/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_2_10/</guid><description>題目： Huffman ： 維基百科
霍夫曼樹經常被用來作資料壓縮，將字串資料轉成霍夫曼碼以減少字串資料所佔的空間大小，其詳細作法如下： (1)字串中所有的字母元素都放在最底層的葉節點上，節點中的值為此字母的出現次數。 (2) 每次從尚無父節點的所有節點中，尋找值最小（出現次數最少）的兩個節點來建立霍夫曼樹， 產生其父節點的值為兩個節點值相加的和。最後只剩下根節點沒有父節點。 (3) 從根節點開始往下編碼，左分支為 0，右分支為 1，每個葉節點的字母元素會產生一個霍夫 曼碼（由 0 和 1 所組成），字母元素出現的頻率越高則霍夫曼碼越短。 我們這題需要計算一個字串轉成霍夫曼碼的壓縮率。假設有個字串&amp;quot;queue&amp;quot;，則此字串會佔5 bytes = 40bits空間， 轉成霍夫曼碼後應為&amp;quot;00011011&amp;quot;，只需要8個bits就可儲存，因此壓縮率為(40-8)/40 * 100% = 80%。 輸入： 輸入一列字串(長度最多100字元，且不含空格)。 輸出： 依序輸出此字串壓縮前的bit數、壓縮後的bit數、壓縮率百分比(格式為⌊n⌋%，即n向下取整)。 Ex 1 Input: queue Ex 2 Input: abadcafcabfdec Ex 3 Input: aaaaaaamcmhhhhhmkkkkkkkkmbbmdddddddmyymppppp Ex 4 Input: BCBBB Ex 1 Output: 40 8 80% Ex 2 Output: 112 35 68% Ex 3 Output: 352 132 62% Ex 4 Output: 40 5 87% 題解： 題目沒說字串中大小寫是否要算成同一字母，因此先視為不同的來處理。</description></item><item><title>算法筆記-基本/初階資料結構</title><link>/posts/2021/algo/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/algo/</guid><description>基礎資料結構 我們程式想儲存東西有很多種方式，而資料結構就像一種容器，
可以儲存或拿取需要的東西，每種資料結構都有不同的複雜度，
如果用得好，效率就會高。
以下都是最基本的資料結構
1.Vector - 向量 in &amp;lt;vector&amp;gt; 1vector&amp;lt;int&amp;gt; v; 向量可當成陣列來用，應該說它就是更強的陣列，而且易維護。
比起原本陣列，它可以自動擴大容量，
能用的空間也比陣列還多。但要注意的是，如果使用operator[]存取了未配置的記憶體位置，
會導致Segmentation Fault。
以下為vector的功能： -- vector[n] 存取索引值為n的元素 -- vector.at(n) 存取索引值為n的元素(較安全) -- vector.begin() 回傳指向vector第一個元素的疊代器 -- vector.end() 回傳指向vector最後一個元素再下一個的疊代器 -- vector.front() 回傳vector[0] -- vector.back() 回傳vector最後一個元素的值 -- vector.size() 回傳目前vector儲存了多少元素 -- vector.resize(n) 修改vector大小 -- vector.capacity() 存取可容納最大個數 -- vector.empty() 回傳布林值表示vector是不是空的 -- vector.reserve(n) 配置更多記憶體以容納更多元素 -- vector.push_back(n) 把n放到vector最尾端 -- vector.pop_back() 把vector最尾端元素取出 -- vector.insert(it,n) 在疊代器it後插入元素n -- vector.erase(it,(it2)) 刪除疊代器it~it2的元素 -- vector.clear() 刪除所有元素 -- vector.swap(vector2) 交換兩個vector 以下是一個使用vector的範例：</description></item><item><title>算法筆記-排序</title><link>/posts/2021/algo-sorting/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/algo-sorting/</guid><description>排序 排序是將一串資料依優先度排列，通常是遞增、遞減、字典序排列，
可以自訂順序，這裡直接使用快速排序法，後面分治會提到合併排序，
快慢隨題目而變動。
我們學校會學到最經典的氣泡排序法，其實是個很不好的排序法，
它最差情況的時間複雜度會炸到$O(n^2)$。
在C++，有函數 sort() 可以直接排序，
以遞增排序為例，原理是先從資料群選一個基準點，
然後從資料兩邊往中間搜，若右邊比基準點小且左邊比基準點大，就將左右邊互換，
直到左右邊相遇，將相遇的點與基準點互換。
複雜度是$O(nlogn)$。
想體驗sort()的力量，我們用random_shuffle()這個函數來打亂區間。
1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3signed main(){ 4 vector&amp;lt;int&amp;gt; a={9,8,7,6,5,4,3,2,1}; 5 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 6 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 7 8 random_shuffle(a.begin(),a.end()); 9 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 10 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 11 12 sort(a.begin(),a.end()); 13 for(auto i:a) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;; 14 cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 15 16 return 0; 17} sort()預設是遞增排列，如果想遞減排列，可以在第三個引數加上 less&amp;lt;型態&amp;gt;()，</description></item><item><title>算法筆記-時間複雜度概述</title><link>/posts/2021/algo-runtime/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/algo-runtime/</guid><description>時間複雜度在競程中是個非常重要且最基本的工具，
係用於估算程式執行N次，大概需要花多久時間。
我們在程式中做的任何事情可能都需要花費1單位時間，
比如五則運算、條件判斷、變數存賦等。
而我們通常會使用函式$O(Big-O)$ 來表示程式的複雜度。
對於$O()$，有以下定義：
$$ Def:\
\qquad If\ f(x) = O(g(x)),\ ∃M,x_0 &amp;gt; 0,\ such \ that \ ∀x&amp;gt;=x_0,then \ |f(x)| &amp;lt;= M|g(x)| $$
為什麼我們需要估時間複雜度？
因為我們在寫程式追求的是速度！當你的演算法太慢(時間複雜度太大)時，
就算結果是對的，但你會在Online Judge上或APCS得到一個TLE(Time Limit Exceeded)，
即若將測資丟到你的程式，會超出該題目所規定的執行時間。
要如何估自己的程式會跑幾秒？
通常，Judge的執行速度大約是1e8筆/秒，因此只要將題目的範圍限制代入所估複雜度，
然後除以1e8，就能大概知道自己程式會不會TLE了。
常見的複雜度有： $1,n,n^2,n^3,nlogn,2^n$。 而log通常以2為底但我們不太會去明指以誰為底。
以下是複雜度計算的原則：
&amp;ndash; 1.常數倍數不計( $O(2n) = O(n) = O(3n)$ )。
&amp;ndash; 2.若將程式分成兩段複雜度為$O(f(n)),\ O(g(n))$,總複雜度就取複雜度比較大的那段。
即$O(f(n)+g(n)) = O(f(n)) &amp;gt; O(g(n)) ? O(f(n)) : O(g(n))$
&amp;ndash; 3.若有一段程式複雜度為$O(f(n))$執行$g(n)$次，總複雜度是$O(f(n)*g(n))$。</description></item><item><title>算法筆記-進階資料結構-線段樹</title><link>/posts/2021/algo-segtree/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/algo-segtree/</guid><description>回到算法筆記-進階資料結構
線段樹 Segment Tree是一種二元樹，適合解決RMQ問題(查詢區間極值)、區間和， 適合用於單點修改、區間修改。
成功實現Sparse Table做不到的事。
每個節點可以存一種區間的數據(比如區間和)，
根節點存[1,n]的數據，每個左子節點編號是index*2，右邊為index*2+1，
左邊紀錄[l,(l+r)/2)，右邊紀錄[(l+r)/2+1,r]。
通常，線段樹會開4倍大
1int T[4*N],a[N]; // int T[N&amp;lt;&amp;lt;2]; 建立線段樹，若l==r，此節點即a[l] 子樹建完後就把資料合併
1void build(int l,int r,int index){ 2 if(l==r){ 3 T[l] = a[l]; 4 } 5 else{ 6 int mid = l+(r-l)/2; // 避免 (l+r)/2 溢位 7 build(index*2,l,mid); // build(index&amp;lt;&amp;lt;1,l,mid); 8 build(index*2+1,mid+1,r); 9 T[index] = T[index*2] + T[index*2+1] ; 10 } 11} 詢問區間(ql,qr:要查的區間 l,r:此節點儲存的左右界) 1int query(int ql,int qr,int l,int r,int index){ 2 if(ql&amp;lt;=l &amp;amp;&amp;amp; qr&amp;gt;=r) return T[index]; 3 int mid = l+(r-l)/2; 4 int rt=0; 5 if(ql&amp;gt;mid) rt+=query(ql,qr,mid+1,r,index*2+1); 6 if(qr&amp;lt;=mid) rt+=query(ql,qr,l,mid,index*2); 7 return rt; 8} 單點修改 1void modify(int l,int r,int pos,int index,int val){ 2 if(l==r){ 3 T[index] = val;return; 4 } 5 int mid = l+(r-l)/2; 6 if(pos&amp;lt;=mid) modify(l,mid,pos,index*2,val); 7 else modify(mid+1,r,pos,index*2+1,val); 8 T[index] = T[index*2]+T[index*2+1]; 9} 懶人標記 如果想在[l,r]中的所有元素加值怎麼辦？ 不可能一個一個呼叫modify吧。</description></item><item><title>算法筆記-關於優化</title><link>/posts/2021/algo-io/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/algo-io/</guid><description>編譯器優化 我們的程式變成執行檔時需要經過一連串的轉譯與運算，
如果改變編譯器的編譯模式，或者改變寫程式的習慣，有可能會讓效率變更高。
一般的Judge編譯器模式都是O2，是個比較安全的運算方式。
但其實我們可以在程式中再加入一些指令，改變編譯器的運算方式。
1#pragma GCC optimize(&amp;#34;Ofast&amp;#34;) 2//以較不安全的運算來編譯程式 3#pragma loop_opt(on) 4//迴圈優化 5#pragma comment(linker,&amp;#34;/stack:200000000&amp;#34;) 6//更改最大堆疊數 以上是我常用的編譯器優化指令，
請注意不是所有OJ都支援pragma優化。
I/O優化 當我們比較cout、cin與printf、scanf時，會發現後者比前者快非常多。
這是因為每次在輸入輸出前，程式會將資料放進一個緩衝區(內存)，然後再從內存裡拿出。
我們應該減少拿取的動作，因為這非常耗時。
如果做過CF互動題，會發現題目會要求在輸出後加上cout.flush()，就是要把資料強制輸出，
否則它可能要等到程式結束後才輸出。
cin，它的原理其實是讀取鍵盤輸入的字，再輸出給使用者看打了什麼，
這就讓拿取的動作暴增了，解決方法是加上 cin.tie(0);
讓內存強制釋放掉。
C++有兩種輸出輸入，分別是stdio與iostream，而程式可能會搞混而發生問題
，使得效率變差，這時就加上 ios_base::sync_with_stdio(false); 就解決了
加上這行後，之後的輸入輸出就是選(cin,cout)或(scanf,printf)其中一個，
再混用的話它們會生氣
C++的換行可以是endl或'\n'，而其實 cout &amp;lt;&amp;lt; endl 相當於 cout &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; flush
也就是它順便把內存清空了，做了多餘的動作。
之後記得要換行的話就用'\n&amp;rsquo;別再用endl了。 或放個 #define endl '\n'</description></item><item><title>C++筆記-語法</title><link>/posts/2021/cpp/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/2021/cpp/</guid><description>目錄： 基礎C++模板
變數概論
邏輯與運算子
輸入/輸出與流
基礎C++模板 我在比CF、學科能力競賽還是平常練習都是用C++當主要語言，這裡就從基本的模板開始
*所有內容將以版本C++17為準
直接附上STL標頭檔：
1#include&amp;lt;bits/stdc++.h&amp;gt;注意，比競程時再用他，如果是其他用途的話最好是不要引入這個
這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 &amp;lt;algorithm&amp;gt; 裡的__gcd(計算最大公因數)
不過有些編譯器不包含這個標頭檔，就自己Google找找對應的解決方法吧。
有時候看別人的Code還會看到一個標頭檔 &amp;lt;bits/extc++.h&amp;gt; ，那是內建紅黑樹、雜湊表的標頭檔，但我打競程到現在還沒用過他，所以就不提了。
然後為了方便，會在下面定義名稱空間 using namespace std; ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣我們在做像是輸入輸出(cin、cout)等操作時 不需要在前面加上 std:: 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。
而每個程式都會需要一個叫做main的主函式，這個函式就是一切的起點，也是終點：
1int main(){ 2 return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。 3} 在這裡我們就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。
注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當我們在引入標頭檔以及有大括號時則不需要分號，因為在C++，&amp;ldquo;引入標頭檔&amp;quot;這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。
總結程式碼： 1#include&amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main(){ 4 return 0; 5} 變數概論 首先我認為一開始學程式最容易搞不懂的是變數的作用範圍以及他們的型別，再來以下內容有些會適用於其他程式語言：
程式如何判別這是一個字？還是一個句子？還是一個變數？ 對於大部分程式語言來說，會用引號('',&amp;quot;&amp;quot;)來判斷。 在C++中，只要沒有引號，那這就是一個變數，而單引號意味著這是一個字元，雙引號則是字串 要注意，字元是只能由一個字母、數字或符號組成的，而字串是包含著一堆字元，此部分將後面會提到 我們要如何宣告一個變數？很簡單，格式為 (變數型態) (變數名稱)，我們可以一次宣告很多變數： (型態) (名稱),(名稱),(名稱)...;
ex: int a,b,c;</description></item><item><title>Farmbot歷程</title><link>/posts/2021/farmbot/</link><pubDate>Thu, 11 Feb 2021 00:00:00 +0000</pubDate><guid>/posts/2021/farmbot/</guid><description>Farmbot
(本頁面在舊版網站發布，會有不少顯示問題)
FBTUG共筆資料
什麼是Farmbot? 一個機器人開放式系統，可通過土地種植，澆水，土壤測試和除草為所有需要耕種小土地跟想種糧食的人提供幫助
使用Raspberry Pi(樹莓派)，Arduino以及其他優良組件
1.碳足跡 製造 目前看重環保議題,Farmbot使用最普遍的材料:
材料 用途 重量(kg) kg CO2/物料 kg CO2(kg) 鋁 擠壓板 9.5 8.24 78.3 不鏽鋼 硬件，軸承，驅動軸，絲槓 1.4 6.15 8.6 塑料 拖鏈，3D列印[CAD]，輪子，電子設備，管材，電路板 2.8 2.53 7.1 銅 電，佈線，電動機繞組 0.3 2.60 0.8 橡膠 皮帶，電線，墊片 0.2 3.18 0.6 合計 95.4 每生產Farmbot排放的理論量約 95.</description></item><item><title>Python遊戲設計</title><link>/posts/2021/pythongame/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>/posts/2021/pythongame/</guid><description>FOR Python遊戲設計 檔案庫: Here
Python程式列表(全自寫): LIST
Cocos2d: Docs
第一堂: IDE: pycharm CE, Module: cocos2d 彭彭-Python程式設計入門
Colab
CBE30338
記得寫程式可放個小抄在旁邊&amp;hellip;
有問題請點這個
作業: 遊玩CodeCombat
第二堂 安裝Pycharm : Pycharm
Community版為開源,免費 / Professional為完整版(30天免費試用)
需要先安裝Python (Ver. &amp;gt;3.7),Windows:可在Microsoft市集搜尋Python / MacOS可在官網上下載 / Linux有些版本已預安裝,安裝方式: ($ apt update &amp;amp;&amp;amp; apt install python3)
安裝方式: Here
設定: here
安裝Cocos2d: Files&amp;gt;Setting&amp;gt;Project: Inter..&amp;gt;(+)&amp;gt;搜尋cocos2d&amp;gt;安裝
學程式的技巧: 先抄再讀 不懂可Google
Vim: 分為命令模式,插入模式,底線命令模式,視覺模式
命令模式: 為預設模式,在任何模式中按下Esc即可到此模式,可按下某些鍵來切換模式
插入模式: 切換方式:在命令模式中按下i,a,o等按鍵,可在游標位置插入需要的文字
底線命令模式: 切換方式:按下:,可輸入指令操作內容,
離開: :q
強制離開: :q!
存檔不離開: :w</description></item><item><title>資源</title><link>/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/resources/</guid><description>解題系統：
TIOJ
CSES
ZeroJudge
Codeforces
Uva
洛谷
自己亂搞的OJ</description></item></channel></rss>