---
title: 【TIOJ】1903-你的笑容由我來守護-EXTREME
date: 2022-05-13
tags:
  - algorithms
---

# **題目：**
	
給一張$N$個點的無向圖，一開始有$M$條邊。
接著$Q$個操作，有以下兩種：
	
* 增加一條連著$A_i$、$B_i$的邊。
* 刪除一條連著$A_i$、$B_i$的邊(保證這條邊存在)。

每次操作完後輸出當前連通塊數量。

* $1 \le N \le 5e5$
* $M+Q \le 5e5$
* $0 \le A_i,B_i \le N-1$
* $A_i \neq B_i$

# 輸入：

第一行有一個數字T代表測資筆數。

每筆測資第1行有3個整數N、M、Q。

接下來M行每行兩個整數Ai、Bi，代表Ai和Bi這兩個人目標相同。

接下來Q行，每行有一個字元 c 和兩個整數Ai、Bi，代表修改一個紀錄。

如果 c 是 N，代表增加一筆 Ai、Bi 兩人目標相同的紀錄；

如果 c 是 D，代表要刪除一筆 Ai、Bi 目標相同的紀錄，所有刪除都是合法的。


# 輸出：

對於每筆測資的Q筆修改，每次修改完輸出一行代表連通塊數量。

#### Ex 1 Input:
```
2
3 0 3
N 0 1
N 1 2
N 2 1
3 3 3
0 1
1 2
2 1
D 2 1
D 0 1
D 2 1
```

#### Ex 1 Output:
```
2
1
1
1
2
3
```

# 題解：

動態維護連通塊數量可以使用並查集(DSU)，但多了刪除的操作。

其實刪除操作就只是倒著做回去，只要事先紀錄原本的父節點並啟發式合併壓複雜度即可。

而要將兩者結合，就需要拿出特殊的資料結構：時間線段樹，然後先把所有操作都讀入再一個一個做。

需要注意的地方： 
* 這題用cin+IO優化輸入會卡常，必須用scanf或自己寫輸入函式
* unordered_map<pii,pii> 沒有內建hash，要自己做


```cpp
#pragma GCC optimize("Ofast")
#pragma loop_opt(on)
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;

template<class T> long long Mod(T a,T b){return ((a%b)+b)%b;}
#define endl '\n'
#define ll long long
//#define int long long
#define CHIWAWA ios_base::sync_with_stdio(0); cin.tie(0);
#define GETOUT cout.tie(0);
#define gc getchar()
#define cendl putchar('\n');
template<class T> bool chmax(T &a,T b){return a<b?(a=b,1):0;} 
template<class T> bool chmin(T &a,T b){return a>b?(a=b,1):0;} 
#define fr(bob,n,l) for(int bob=(n);bob<(l);bob++)
#define fra(ns,a) for(auto (ns):a)
#define frc(bot,ns,l) for(int bot=(ns);bot<=(l);bot++)
#define frx(i,ns,l) for(int i=(ns);i<(l);i++)
#define mem(arr,initn) memset(arr,initn,sizeof(arr))
#define ALL(va) (va).begin(),(va).end()
#define ALLa(arr) (arr),(arr)+sizeof((arr))/sizeof((arr)[0])
#define printv(va) {fr(i,0,size((va))){cerr<<(va)[i]<< ' ';}cendl;}
#define printa(va) {fr(i,0,sizeof((va))/sizeof((va)[0])){cerr << (va)[i] << ' ';}cendl;}
#define getpos(va,v) lower_bound((v).begin(),(v).end(),(va)) - (v).begin()
#define arrpos(i,va) distance((va),find(ALLa((va)),i))

#define pb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<long double,long double> pdd;
typedef vector<int> vii;
#define fi first
#define se second

const int MAX=1e9+7;
const int MOD=998244353;

inline int nextint(){
	int x=0,w=1;char ch=0;
  	while(ch<'0'||ch>'9'){ 
    	if(ch == '-')w=-1; 
    	ch=getchar();               
  	}
  	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch-'0'),ch=getchar();
  	return x*w;
}
const int NN = 5e5+3;
namespace std{
    template<>struct hash<pii>{
        ll operator()(const pii &p) const{
            return //自訂Hash;
        }
    };
}
struct Event{
    pii a,pastsz,pastpar,sz;
    void init(pii _a,pii _pastsz,pii _pastpar,pii _sz){
        a = _a;pastsz = _pastsz;pastpar = _pastpar;sz = _sz;
    }
};
vector<Event> et;
struct undo_DSU{
    int cnt;
    int sz[NN];
    int parent[NN];
    void init(int n){
        cnt = n;
        frc(i,0,n){
           parent[i]  = i; 
           sz[i] = 1; 
        } 
    }
    int query(int x){
        while(x!=parent[x]) x = parent[x];
        return x;
    }
    bool Union(int x,int y,pii r){
        x = query(x);y = query(y);
        if(x==y) return 0;
        if(sz[x]<sz[y]) swap(x,y); // 啟發式合併
        Event e;
        e.init({x,y},{sz[x],sz[y]},{parent[x],parent[y]},r);
        et.pb(e);
        cnt--;
        sz[x]+=sz[y];
        parent[y] = parent[x];
        return 1;
    }
    void undo(Event e){
        parent[e.a.fi] = e.pastpar.fi;
        parent[e.a.se] = e.pastpar.se;
        sz[e.a.fi] = e.pastsz.fi;
        sz[e.a.se] = e.pastsz.se;
        cnt++;
    }
} dd;
int ans[NN];
struct Node{
    static Node TTree[4*NN];
    Node *l,*r;
    vector<pii> v;
    Node(){
        l = r = nullptr; v.clear();
    }
} TTree[4*NN],*ptr = TTree;

Node *build(int l,int r){
    Node *ret = new(ptr++) Node();
    if(l==r) return ret;
    int mid = (l+r)>>1;
    ret->l = build(l,mid);
    ret->r = build(mid+1,r);
    return ret;
}
void modify(Node *a,int l,int r,int ql,int qr,pii edge){
    if(l>qr||ql>r) return;
    else if(ql<=l&&r<=qr){
        a->v.pb(edge);return;
    }
    int mid = (l+r)>>1;
    modify(a->l,l,mid,ql,qr,edge);
    modify(a->r,mid+1,r,ql,qr,edge);
}
void find(Node *a,int l,int r){
    fra(i,a->v) dd.Union(i.fi,i.se,{l,r});
    if(l==r) ans[l] = dd.cnt;
    else{
        int mid = (l+r)>>1;
        find(a->l,l,mid);
        find(a->r,mid+1,r);
    }
    while(!et.empty()&&et.back().sz == make_pair(l,r)){
        dd.undo(et.back());
        et.pop_back();
    }
}
inline void solve(){

	ptr = TTree;
	int n = nextint(),m = nextint(),q = nextint();
    dd.init(n);
    unordered_map<pii,pii> event;
    Node *root = build(1,q+1);
	frc(i,1,m){
        int a = nextint(),b = nextint(); 
        if(a>b) swap(a,b);
        if(event[{a,b}] == make_pair(0,0)) event[{a,b}] = {1,1};
        else event[{a,b}].se++; 
    }
    frc(i,2,q+1){
        char c;int a,b;
        scanf("%c",&c);
        a = nextint(),b = nextint();
        if(a>b) swap(a,b);
        if(c=='N'){
            pii ret = event[{a,b}];
            if(ret == make_pair(0,0)) event[{a,b}] = {i,1};
            else{
                ret.se++;
                event[{a,b}] = ret;
            }
        }
        else if(c=='D'){
            pii ret = event[{a,b}];
            ret.se--;
            if(ret.se == 0){
                modify(root,1,q+1,ret.fi,i-1,{a,b});
                ret = {0,0};
            }
            event[{a,b}] = ret;
        }
    }
    fra(i,event){
        if(i.se.se == 0) continue; 
        modify(root,1,q+1,i.se.fi,q+1,i.fi);
    }
    find(root,1,q+1);
    frc(i,2,q+1) cout << ans[i] << endl;

}
signed main(){
	int t=1;
	t = nextint();
	while(t--)solve();

	return 0;
}
```


