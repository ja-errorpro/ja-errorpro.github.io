---
title: C++筆記-語法
date: 2021-08-16
tags:
  - C-Cpp
---

<meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>

# 目錄：
- [基礎C++模板](#基礎C++模板)

- [變數概論](#變數概論)

- [邏輯與運算子](#邏輯與運算子)

- [輸入/輸出與流](#輸入輸出與流Buffer概念)

---

# 基礎C++模板

我在比CF、學科能力競賽還是平常練習都是用C++當主要語言，這裡就從基本的模板開始

*所有內容將以版本C++17為準

直接附上STL標頭檔：

```cpp
#include<bits/stdc++.h>
```

**注意，比競程時再用他，如果是其他用途的話最好是不要引入這個**

這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 ``<algorithm>`` 裡的__gcd(計算最大公因數)

不過有些編譯器不包含這個標頭檔，就自己Google找找對應的解決方法吧。

有時候看別人的Code還會看到一個標頭檔 ``<bits/extc++.h>`` ，那是內建紅黑樹、雜湊表的標頭檔，~~但我打競程到現在還沒用過他~~，所以就不提了。

然後為了方便，會在下面定義名稱空間 ``using namespace std;`` ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣我們在做像是輸入輸出(cin、cout)等操作時
不需要在前面加上 ``std::`` 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。

而每個程式都會需要一個叫做main的主函式，這個函式就是一切的起點，也是終點：
```cpp
int main(){
	return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。
}
```

在這裡我們就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。

注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當我們在引入標頭檔以及有大括號時則不需要分號，因為在C++，"引入標頭檔"這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。

## 總結程式碼：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	return 0;
}
```


---

# 變數概論

首先我認為一開始學程式最容易搞不懂的是變數的作用範圍以及他們的型別，再來以下內容有些會適用於其他程式語言：

```
程式如何判別這是一個字？還是一個句子？還是一個變數？
對於大部分程式語言來說，會用引號('',"")來判斷。
在C++中，只要沒有引號，那這就是一個變數，而單引號意味著這是一個字元，雙引號則是字串
要注意，字元是只能由一個字母、數字或符號組成的，而字串是包含著一堆字元，此部分將後面會提到
```

我們要如何宣告一個變數？很簡單，格式為 ``(變數型態) (變數名稱)``，我們可以一次宣告很多變數： ``(型態) (名稱),(名稱),(名稱)...;``

ex: ``int a,b,c;``

要注意的是，變數的名稱在同作用範圍下不可重複，只能為英數字、底線(_)、開頭不可為數字、且不能是C++裡面已經定義的名稱(ex:int,char,double,long...)

現在，直接上變數型態：

### 一、整數

每種整數資料型態都會有一定的值域，若超過的話會發生溢位，使得答案出錯
而signed/unsigned表示型態含不含符號，而負數前面都會有一個 "-" ，因此當型態為unsigned時，是將所有負值的空間加到正值，讓正值值域更大

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| short/short int | 2 Bytes | -2^15~2^15-1 | 短整數 |
| unsigned short/unsigned short int | 2 Bytes | 0~2^16-1 | 無符號短整數 |
| int/long int/signed/signed long int/long | 4 Bytes | -2^31~2^31-1 | 整數 |
| unsigned int/unsigned long int/unsigned | 4 Bytes | 0~2^32-1 | 無符號整數 |
| long long/long long int | 8 Bytes | -2^63~2^63-1 | 長整數 |
| unsigned long long/unsigned long long int | 8 Bytes | 0~2^64-1 | 無符號長整數 |

### 二、浮點數

就是有小數點的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| float | 4 Bytes | -3.4E38~3.4E38 | 單精度浮點數 |
| double/long double | 8 Bytes | -1.7E308~1.7E308 | 倍精度浮點數 |

#### 在競程中，建議用double為主，因為double在計算上的精準度比float來得高很多。

### 三、字串與字元

用來儲存文字的東西

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| char | 1 Bytes | 0~277 | 字元 |
| string | 不定 | 每個0~277 | 字串 |

string 其實可以說是字元的組合，在c++它是比char好用的東西，之後會在講陣列/字串操作時提到。

### 四、布林值

用來判斷條件的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| bool | 1 Bytes | 0/1、true/false | 布林值 |

它只能存true(真)或者false(假)，通常用於判斷條件的成立

---

## 作用範圍

我們可以將變數的作用範圍分為 **全域性變數**、**區域性變數**、當然還有**靜態變數**、**常數**

定義：
- 全域性變數：在程式任何地方都可以調用
- 區域性變數：在特定的記憶體範圍中可以調用
- 靜態變數：宣告之後可作為全域性變數使用
- 常數：宣告之後不可再更動其值

這樣說可能還是有點模糊，上程式碼：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int s=0; //s是常數，如果我在程式的某個地方修改它的值，會報錯
int a; // a是全域變數，可以在f函式也可以在main裡使用
int f(){
	return 1;
}
int main(){
	static int b; //b是靜態變數，我可以拿到main函式以外的地方使用
	int c;// c是區域變數，只能在main裡用
	return 0;
}
```

我們程式是**由上往下**讀的，因此如果在上面程式碼中的f函式、main函式中間再加一個變數m，則這個變數只能在m下面的程式中也就是main函式中調用。

---

# 邏輯與運算子

我們學程式語言，一定不能不會的是邏輯與位元運算，  
以下都會是超常使用的運算子，必須記好記滿。  

| 優先度 | 運算子 | 描述 | 閱讀順序 | 例子 |
|---------|---------|---------|---------|---------|
| 1 | :: | 作用域，當你的程式複雜起來再用它，目前暫時都用不到 | -> | std::cout << endl; |
| 2 | ++/\--<br>()<br>[]<br>.<br>-> | 先回傳再加/減1<br>函式呼叫<br>Operator 陣列存取<br>物件存取成員<br>指標存取成員 | -> | i++/i\--<br>int a = f(x);<br> int a[10];<br>obj.cmp = 0;<br>ptr->val = 0; |
| 3 | ++/\--<br>+/-<br>!<br>~<br>(Type)<br>\*<br>&<br>sizeof | 先加/減1再回傳<br>正負號<br>邏輯NOT<br>位元取反<br>強制轉換類型<br>指標指向的值<br>指標位址<br>所佔位元組大小 | <- | ++i/\--i<br>+/-1<br>while(!true)<br>a = ~a;<br>int i=int(doublex);<br>int k = \*a;<br>int \*k = &a;<br>cout << sizeof(int);//4 |
| 4 | \*<br>/<br>% | 乘<br>除<br>取模 | -> | int a = 8\*8;<br>int a = 20/6;<br>int a = 6%4; |
| 5 | +/- | 加/減 | -> | int a = 6+4; |
| 6 | >>/<< | 位元右/左移(除/乘2的n次方) | -> | int a = 4 >> 3; |
| 7 | </<=/>/>= | 大小等於 | -> | if(a < 0) |
| 8 | ==/!= | 等於/不等於 | -> | while(a!=0) |
| 9 | & | 位元AND運算 | -> | n = x&1 |
| 10 | ^ | 位元XOR運算 | -> | n = x^1 |
| 11 | \| | 位元OR運算 | -> | n = x\|1 |
| 12 | && | 邏輯AND | -> | if(1==3 && 2==2) |
| 13 | \|\| | 邏輯OR | -> | if(1==3 \|\| 2==2) |
| 14 | c?p1:p2 | 三元條件運算(可當成if-else) | <- | int i = a>b?a:b; |
| 15 | =/+=/-=/\*=//=/%=/<<=/>>=/&=/^=/\|= | 賦值 | <- | a+=3;b&=1; |
| 16 | , | 逗號 | -> | int i,j,k; |

這裡我們特別關注邏輯運算AND、OR、XOR，  
它們的運算方式都要從二進位表示法來看，  
要一個一個位數來算。  

使用AND運算結果如下：  

| P | Q | 結果 |
| 0 | 0 | 0 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

舉例：  
$$ 9_{10}\&8_{10} = (1001)_2 \& (1000)_2 = (1000)_2 = 8_{10} $$  

可觀察只有當兩位元都是1時輸出才是1。  

我們可以將它應用在判斷奇偶數： 
```cpp
cout << (x&1?"Yes":"No") ;
```

使用OR運算結果如下：  

| P | Q | 結果 |
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

舉例：  
$$ 10_{10}|8_{10} = (1010)_2 | (1000)_2 = (1010)_2 = 10_{10} $$ 

只要有位元為1，則輸出就是1。  

使用XOR運算結果如下：  

| P | Q | 結果 |
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

舉例：  
$$ 10_{10} $$^$$ 8_{10} = (1010)_2 $$^$$ (1000)_2 = (0010)_2 = 2_{10} $$ 

兩個位元只能有一個是1，其他情況都回傳0。  

它的用途更廣，你可以用它將兩個數交換：  
```cpp
a^=b;
b^=a;
a^=b;
```

可以判別一個陣列中哪個數缺少：  

```cpp
int a[]={1,2,3,5,6,7,8,9};
int n=0;
for(int i=0;i<9;i++) n^=i;
for(int i=0;i<9;i++) n^=a[i];
cout << n;
```

可以做大小寫轉換：  

```cpp
char tolower(char c){
	return (c>='A'&&c<='Z')?c^32:c;
}
char toupper(char c){
	return (c>='a'&&c<='z')?c^32:c;
}
```
## 補充 - 常數：  
我們如果想固定某數，不讓它在程式裡被更改，可以使用 `const` 
```cpp
const int MAX = 2147483647;
```
這就是定義常數的方式。  
如果它被更動，程式會出錯。  

## 補充 - 巨集：
有時候，我們不想打那麼多字，為節省時間，可以在前面先定義  
一個巨集： `#define`
```cpp
#define int long long 
//讓所有整數都變成長整數，之後用int宣告的話都會宣告成long long
#define pb push_back
//把指令縮短，之後要用就打pb就好
```

有時候如果定義的巨集是變數型態也可以用`typedef`
```cpp
typedef long long ll
//之後宣告long long就打ll就好
```


---

# 輸入/輸出與流Buffer概念

## 流
在c++我們需要了解一下流跟緩衝區的概念，  
C++這個語言本來是沒有IO功能的，  
基本的輸入輸出定義於`<iostream>`與`<fstream>`這兩個標準模板庫(std)裡，  
它們被分成了三個標準：  
istream/ cin、wcin ： 標準輸入流  
ostream/ cout、wcout ： 標準輸出流  
ostream/ cerr、wcerr ： 標準錯誤輸出流(無緩衝)  
ostream/ clog、wclog ： 標準錯誤輸出流(有緩衝)  

輸入的方式，是使用(>>)從輸入流中擷取資料，而輸出則是用(<<)將資料擷取到輸出流。  
這就是一開始學校在教程式時會說輸入就是 `cin >> x;`，輸出是 `cout << x;`，箭號方向不能交換。  

## 緩衝區  
緩衝區的定義是 `用作中介的內存塊`，這樣說可能沒人懂，  
它就是先把資料全部移到一個地方(內存)，再去慢慢讀取的概念。  
因為程式只能一個字一個字讀，如果直接讀，程式會變超慢，   
也就是當程式頻繁進行IO操作，會頻繁把高速的部分打斷，  
造成性能下降。  

緩衝區的功用就在於避開頻繁操作，只要讀取緩衝區的資料就好。  
只有需要時再刷新緩衝區進行IO操作，讓程式性能提升。  

以下狀況會刷新緩衝區：  
* 使用cin  
* 釋放cout的資源
* 使用endl、fflush
* 程式正常結束


關於IO優化等操作，可查閱[算法筆記](./algo)


## 輸入  
在C++我們使用cin輸入文字，  
方法很簡單，不像C語言還要指定型別，直接 `cin >> x;` 就是輸入資料到x。  
當我們要輸入多筆資料，只要在後面繼續加就好 `cin >> x >> y >> z;`。  
而cin的好處同時也是壞處就是若輸入空格會自動斷開，  
當我想輸入一句話 `This is a Simple Sentence.` 進一個字串，  
如果使用cin，最後字串可能只會存到 `This` 而已。

因此這裡介紹另一種輸入 `getline()`，  
它的功能是直接讀取整行資料，也就是它會連空格一起讀進去，  
直到換行為止。  

```cpp
getline(cin,s,' ') //getline(輸入流, 字串,切割字元(可以不填))
```
注意這個函式只能輸入字串。  

輸入完後我們通常要將字串切成好幾份資料，  
這時我們就會用到字串流 `stringstream`  
可以把它想成另一種cin，只是它要存字串。  
```cpp
string s;
getline(cin,s);
stringstream ss(s); //初始化s放到字串流裡
```

然後我們就可以去切割它了，用陣列把這些資料儲存起來。  
這裡使用到stol()可以將字串轉成整數。

```cpp
string s,t;
getline(cin,s);
stringstream ss(s);
int a[1000],i=0;
while(getline(ss,t,' ')){
	a[i++] = stol(t);
}
```

## 輸出




---



















