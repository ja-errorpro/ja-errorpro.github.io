---
title: C++筆記-語法
tags:
  - C-Cpp
---

*所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主

## 基礎C++模板



附上STL標頭檔：

```cpp
#include<bits/stdc++.h>
```

**注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個**

這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 ``<algorithm>`` 裡的__gcd(計算最大公因數)

不過有些編譯器不包含這個標頭檔，可以自己Google找到對應的解決方法。

有時候看別人的Code還會看到一個標頭檔 ``<bits/extc++.h>`` ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。

為了方便，會在下面定義名稱空間 ``using namespace std;`` ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣在做像是輸入輸出(cin、cout)等操作時
不需要在每個句子前面加上 ``std::`` 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。
打個比喻，如果說標頭檔是圖書館，那std就是你想找的書。

而每個程式都會需要一個叫做main的主函式，這個函式就是整個程式的起點跟終點：
```cpp
int main(){
	return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。
}
```

在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。

注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在C++，"引入標頭檔"這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。

### 總結程式碼(模板)：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout << "Hello World"; // 你會看到電腦跟你說Hello World
	return 0;
}
```


---

## 變數概論

當我們要進行複雜運算時，變數成為很重要的東西，你可以用變數儲存各種資料，讓電腦記住它。

要如何宣告一個變數？格式為 ``(變數型態) (變數名稱)``，我們可以一次宣告很多變數： ``(型態) (名稱),(名稱),(名稱)...;``

ex: ``int a,b,c;``

要注意的是，變數的名稱在同作用範圍下不可重複，只能為英數字、底線(_)、開頭不可為數字、且不能是C++裡面已經定義的名稱(ex:int,char,double,long...)

### 變數型態：

根據型態的不同，儲存所需容量也會不同，依照平台而有所差異，如果想知道該型態佔了多少空間，可以使用sizeof()，
以下所提的空間都是在多數32位元機器上佔有空間

### 一、整數

每種整數資料型態都會有一定的值域，若超過的話會發生溢位，使得答案出錯
而signed/unsigned表示型態含不含符號，而負數前面都會有一個 "-" ，因此當型態為unsigned時，是將所有負值的空間加到正值，讓正值值域更大

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| short/short int | 2 Bytes | -2^15~2^15-1 | 短整數 |
| unsigned short/unsigned short int | 2 Bytes | 0~2^16-1 | 無符號短整數 |
| int/long int/signed/signed long int/long | 4 Bytes | -2^31~2^31-1 | 整數 |
| unsigned int/unsigned long int/unsigned | 4 Bytes | 0~2^32-1 | 無符號整數 |
| long long/long long int | 8 Bytes | -2^63~2^63-1 | 長整數 |
| unsigned long long/unsigned long long int | 8 Bytes | 0~2^64-1 | 無符號長整數 |

### 二、浮點數

就是有小數點的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| float | 4 Bytes | -3.4E38~3.4E38 | 單精度浮點數 |
| double/long double | 8 Bytes | -1.7E308~1.7E308 | 倍精度浮點數 |

**在競技程式中，建議用double為主，因為double在計算上的精準度比float來得高很多。**

### 三、字串與字元

用來儲存文字的東西

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| char | 1 Bytes | 0~277 | 字元 |
| string | 不定 | 每個0~277 | 字串 |

string 其實可以說是字元的組合，在c++它是比char好用的東西，之後會在講陣列/字串操作時提到。

### 四、布林值

用來判斷條件的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| bool | 1 Bytes | 0/1、true/false | 布林值 |

它只能存true(真)或者false(假)，通常用於判斷條件的成立

---

### 作用範圍

我們可以將變數的作用範圍分為 **全域性變數**、**區域性變數**、當然還有**靜態變數**、**常數**

定義：
- 全域性變數：在程式任何地方都可以調用
- 區域性變數：在特定的記憶體範圍中可以調用
- 靜態變數：宣告之後可作為全域性變數使用
- 常數：宣告之後不可再更動其值

這樣說可能還是有點模糊，看看這個程式碼：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int s=0; //s是常數，如果在程式的某個地方修改它的值，會報錯
int a; // a是全域變數，可以在f函式也可以在main裡使用
int f(){
	return 1;
}
int main(){
	static int b; //b是靜態變數，可以拿到main函式以外的地方使用
	int c;// c是區域變數，只能在main裡用
	return 0;
}
```

我們程式是**由上往下**讀的，因此如果在上面程式碼中的f函式、main函式中間再加一個變數m，則這個變數只能在m下面的程式中也就是main函式中調用。

---

### 溢值

試試這支有bug的乘法程式，看看它有沒有符合想要的結果：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a = 100000;
    int b = 400000;
    int mul = a*b;
    cout << mul;//輸出 40000000000
    return 0;
}
```

這是因為int只能儲存$-2147483647\sim2147483647$範圍的值，如果超出範圍，會造成不可預期的結果

### 強制轉換類型

C++具有任意強制轉換變數型態的方法，分成隱式轉換跟強制轉換，兩者差別在前者是由編譯器自動轉換，後者由程式設計師強制轉型

```cpp
int a = 7;
double b = 1.2;
int c = a*b;
```

在這支程式中，編譯器會先把整數a轉成浮點數(小轉大)，計算完後，把結果轉成整數(大轉小)直接去掉小數點後的值再賦值給c
，最後c會是8，這就是隱式轉換。

```cpp
int a = 7;
double b = 1.2;
cout << a*(int)b;
```

這次在b前面加了(int)，是將b先轉成整數再進行運算輸出，此為強制轉換。

## 邏輯與運算子

學程式語言，必定要會的是邏輯與位元運算，  
以下是之後會超常使用的運算子，請熟記它們的功能。  

| 優先度 | 運算子 | 描述 | 閱讀順序 | 例子 |
|---------|---------|---------|---------|---------|
| 1 | :: | 作用域，當你的程式複雜起來再用它，目前暫時都用不到 | -> | std::cout << endl; |
| 2 | ++/\--<br>()<br>[]<br>.<br>-> | 先回傳再加減1<br>函式呼叫\\陣列存取\\物件存取成員\\指標存取成員 | -> | i++/i\--  int a = f(x);<br> int a[10];<br>obj.cmp = 0;<br>ptr->val = 0; |
| 3 | ++/\--<br>+/-<br>!<br>~<br>(Type)<br>\*<br>&<br>sizeof | 先加/減1再回傳<br>正負號<br>邏輯NOT<br>位元取反<br>強制轉換類型<br>指標指向的值<br>指標位址<br>所佔位元組大小 | <- | ++i/\--i<br>+/-1<br>while(!true)<br>a = ~a;<br>int i=int(doublex);<br>int k = \*a;<br>int \*k = &a;<br>cout << sizeof(int);//4 |
| 4 | \*<br>/<br>% | 乘<br>除<br>取模 | -> | int a = 8\*8;<br>int a = 20/6;<br>int a = 6%4; |
| 5 | +/- | 加/減 | -> | int a = 6+4; |
| 6 | >>/<< | 位元右/左移(除/乘2的n次方) | -> | int a = 4 >> 3; |
| 7 | </<=/>/>= | 大小等於 | -> | if(a < 0) |
| 8 | ==/!= | 等於/不等於 | -> | while(a!=0) |
| 9 | & | 位元AND運算 | -> | n = x&1 |
| 10 | ^ | 位元XOR運算 | -> | n = x^1 |
| 11 | \| | 位元OR運算 | -> | n = x\|1 |
| 12 | && | 邏輯AND | -> | if(1==3 && 2==2) |
| 13 | \|\| | 邏輯OR | -> | if(1==3 \|\| 2==2) |
| 14 | c?p1:p2 | 三元條件運算(可當成if-else) | <- | int i = a>b?a:b; |
| 15 | =/+=/-=/\*=//=/%=/<<=/>>=/&=/^=/\|= | 賦值 | <- | a+=3;b&=1; |
| 16 | , | 逗號 | -> | int i,j,k; |

這裡我們先特別關注邏輯運算AND、OR、XOR，  
它們的運算方式都要從二進位表示法來看，  
並一個一個位數來做計算。  

使用AND運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

舉例：

$9_{10}\ \\&\ 8_{10}= 1001_2\ \\&\ 1000_2=1000_2=8_{10}$


可觀察只有當兩位元都是1時輸出才是1。  

我們可以將它應用在判斷奇偶數： 
```cpp
cout << (x&1?"Yes":"No") ;
```

使用OR運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

舉例：  
$ 10_{10}\ |\ 8_{10} = 1010_2\ |\ 1000_2 = 1010_2 = 10_{10} $$

只要有位元為1，則輸出就是1。  

使用XOR運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

舉例：  

$ 10_{10} \oplus 8_{10} = 1010_2 \oplus 1000_2 = 0010_2 = 2_{10} $

兩個位元只能有一個是1，其他情況都回傳0。  

它的用途更廣，你可以用它將兩個數交換：  
```cpp
a^=b;
b^=a;
a^=b;
```

可以判別一個陣列中哪個數缺少：  

```cpp
int a[]={1,2,3,5,6,7,8,9};
int n=0;
for(int i=0;i<9;i++) n^=i;
for(int i=0;i<9;i++) n^=a[i];
cout << n;
```

可以做大小寫轉換：  

```cpp
char tolower(char c){
	return (c>='A'&&c<='Z')?c^32:c;
}
char toupper(char c){
	return (c>='a'&&c<='z')?c^32:c;
}
```  

### 補充 - 巨集：
有時候，我們不想打那麼多字，為節省時間，可以在前面先定義  
一個巨集： `#define`
```cpp
#define int long long 
//讓所有整數都變成長整數，之後用int宣告的話都會宣告成long long
#define pb push_back
//把指令縮短，之後要用就打pb就好
```

有時候如果定義的巨集是變數型態也可以用`typedef`
```cpp
typedef long long ll
//之後宣告long long就打ll就好
```


---

## 輸入/輸出與流Buffer概念

### 流
在c++我們需要了解一下流跟緩衝區的概念，  
C++這個語言本來是沒有IO功能的，  
基本的輸入輸出定義於`<iostream>`與`<fstream>`這兩個標準模板庫(std)裡，  
它們被分成了三個標準：  
istream/ cin、wcin ： 標準輸入流  
ostream/ cout、wcout ： 標準輸出流  
ostream/ cerr、wcerr ： 標準錯誤輸出流(無緩衝)  
ostream/ clog、wclog ： 標準錯誤輸出流(有緩衝)  

輸入的方式，是使用(>>)從輸入流中擷取資料，而輸出則是用(<<)將資料擷取到輸出流。  
這就是一開始學校在教程式時會說輸入就是 `cin >> x;`，輸出是 `cout << x;`，箭號方向不能交換。  

### 緩衝區  
緩衝區的定義是 `用作中介的內存塊`，這樣說可能沒人懂，  
它就是先把資料全部移到一個地方(內存)，再去慢慢讀取的概念。  
因為程式只能一個字一個字讀，如果直接讀，程式會變超慢，   
也就是當程式頻繁進行IO操作，會頻繁把高速的部分打斷，  
造成性能下降。  

緩衝區的功用就在於避開頻繁操作，只要讀取緩衝區的資料就好。  
只有需要時再刷新緩衝區進行IO操作，讓程式性能提升。  

以下狀況會刷新緩衝區：  
* 使用cin  
* 釋放cout的資源
* 使用endl、fflush
* 程式正常結束


關於IO優化等操作，可查閱[算法筆記](./algo)


### 輸入  
在C++，我們使用cin(音：西印)輸入文字，  
方法很簡單，不像C語言還要指定型別， `cin >> x;` 就是輸入資料到x。  
當要輸入多筆資料，只要在後面繼續加就好 `cin >> x >> y >> z;`。  

如果不想使用bits/stdc++.h，需要include \<iostream>

範例程式：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int x;
    cin >> x;
    int y,z;
    cin >> y >> z;
    return 0;
}
```

而cin的好處同時也是壞處就是若輸入空格會自動斷開，  
當想輸入一句話 `This is a Simple Sentence.` 進一個字串，  
如果使用cin，最後字串可能只會存到 `This` 而已。

因此這裡介紹另一種輸入 `getline()`，  
它的功能是直接讀取整行資料，也就是它會連空格一起讀進去，  
直到換行為止。  

```cpp
getline(cin,s,' ') //getline(輸入流, 字串,切割字元(可以不填))
```
注意這個函式只能輸入字串。  

輸入完後通常要將字串切成好幾份資料，  
這時就會用到字串流 `stringstream`  
可以把它想成另一種cin，只是它必須存字串。
如果不使用bits/stdc++.h，則要include \<sstream>才能使用stringstream  
```cpp
string s;
getline(cin,s);
stringstream ss(s); //初始化s放到字串流裡
```

然後就可以去切割它了，用陣列把這些資料儲存起來。  
這裡使用到stol()可以將字串轉成整數。

```cpp
string s,t;
getline(cin,s);
stringstream ss(s);
int a[1000],i=0;
while(getline(ss,t,' ')){
	a[i++] = stol(t);
}
```

### 輸出

在最一開始的[模板](#總結程式碼模板)，就可以看到輸出的方法了(cout)，
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int x;
    cin >> x;
	cout << x;
    int y,z;
    cin >> y >> z;
	cout << y << " " << z;
    return 0;
}
```


### 補充

Q:如果使用cerr輸出會發生什麼事？

cerr是用來除錯的，注意有些Judge不會把它當成輸出，你可以用來測試你的程式哪裡寫錯



---

## 字面常數

程式中的0,1,1.1都叫字面常數，代表程式的符號，

整型字面常數包含2,8,10,16進位，其中2進位是C++14才加入的

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int base10 = 1234; // 十進位
    int base8 = 0373; // 八進位
    int base16 = 0xf1; // 十六進位
    int base2 = 0b1010; // 二進位
}
```

對於整數，cout都會以十進位輸出，試試看輸出上面程式中的變數會出現什麼數值。

有時要做運算時可能發現直接使用數字計算，編譯器會報錯，比如要某個型態為long long的值加上10，這時可以在10後面加上LL，編譯器就會把10看作long long型態計算了。

對於浮點數，有很方便的科學記號，1000000000可以寫成1e9，0.0008可以寫成8e-4。

如果要表示字元，可以使用單引號，像是'a','1'，而如果需要用到引號或反斜線的字元時，在前面再加上一條反斜線即可。

字串的字面常量是雙引號，像 "Hello World" 整句是一個字串。

這裡提供一些常用的字元常量：

| 字面常量 | 功能 |
| ------ | ------ |
| \\n | 換行 |
| \\t | 水平定位 |
| \\v | 垂直定位 |
| \\b | 退回 |
| \\r | 回到行首 |
| \\\\\ | 反斜線 |
| \\? | 問號 |
| \\' | 單引號 |
| \\" | 雙引號 |


C++換行有兩種方式，一是使用\\n，另一種則是endl，而布林值中的true, false也是字面常量。

---
## 流程控制


### 選擇結構

藉由前面那些知識，可以做出基本的運算跟輸出輸入了，現在我們可以給程式"做選擇"，實現更多功能。

題目：

	輸入一個正整數，如果他是偶數則輸出Yes，否則輸出No。
	
這時我們可以使用 if(如果)， 用法：
```cpp
if(條件式(condition) ){
    //當條件成立要做的事
}
```

而這題的寫法如：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    if(n%2==0){ // 當 n 除以 2 的餘數為0
	    cout << "Yes" << endl;
	}
	if(n%2!=0){ // 當 n 除以 2 的餘數不為0
	    cout << "No" << endl;
	}
}
```

在條件式中，我們判斷 n \% 2 是否等於 0，% 是取模運算符號，又稱取餘數， n % 2 意思是 n 除以 2 的餘數。


這時我們發現其實上面程式的兩個if一定恰有一個成立，因此可以使用else(否則)代替後面的if

```cpp
if(條件式(condition) ){
    //當條件成立要做的事
}
else{
    //當條件不成立要做的事
}
```

C++還提供了switch結構，用來比較數值或字元

```cpp
switch(變數名稱或運算式){
    case 數字或字元:
	    任務;
		break;
	case 數字或字元:
	    任務;
		break;
	default:
	    任務;
		break;
}
```

switch會把括號裡的變數由上往下跟case設定的數值比對，成功就會執行該case下的任務，然後遇到break離開，
其中default是當沒找到符合的數值字元就會執行，可以省略。


---

### 循環結構

計算機的優勢在於它可以執行大量操作，看看這題：

	輸出1到1000，每個佔一行。
	
我們可以這樣寫：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout << "1\n" << "2\n" << "3\n" << "4\n" ...
}
```

顯然你的手指或鍵盤會先掛掉，那如果是輸入n，輸出1到n，就不能這樣解了，

這時可以使用for-loop：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    for(int i=1;i<=1000;i++){
	    cout << i << endl;
    }
}
```

* for迴圈的格式為：
	for(初始化;條件式;更新式)循環體;

上面的程式中，初始化 i=1，再來程式會檢查i是否<=1000，只要符合，就進到循環體中執行裡面的任務。
當任務做完後，執行更新式(i++)，這時i就會+1，再判斷條件式是否符合，符合就再執行，直到不符合條件時整個for迴圈才會停止。

for迴圈中初始化、條件式、更新式可以視情況省略，但分號必須留著。

```cpp
for(;;){} //無窮迴圈，執行到永遠
```

另外一種迴圈是while，適合用在次數不確定的情況，

```cpp
while(條件式)循環體;
```

考慮這個題目：

考拉茲猜想: 對於任何大於$1$的自然數$n$，若$n$為奇數，將$n$變成$3n+1$，否則變成$\frac{n}{2}$，經過若干次變換，$n$最終會變成$1$，
輸入$n(n \le 10^9)$，求$n$會更新幾次。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n,cnt=0LL;
	cin >> n;
	while(n>1){
	    if(n%2==0) n=n*3+1;
		else n /= 2;
		cnt++;
	}
	cout << cnt << endl;
	return 0;
}

```

為何這裡用long long不用int？注意題目給了範圍$(n \le 10^9)$，試試如果使用int並輸入99999999會發生什麼，
n是奇數，因此程式會將他乘3，但$99999999 \times 3 > 2^{31}-1$，已經超出int範圍了([變數溢值](#溢值))。



最後是do-while，

```cpp
do{
  循環體;
}while(條件式); //記得分號
```

跟while不同的是，do-while會先執行循環體，再判斷條件。


### 控制(break,continue,goto)

break可以離開它上面的switch、for、while、do-while區塊，如果沒把break寫在迴圈裡，會得到
編譯錯誤，

```cpp
int n=0;
while(1){ // 無窮迴圈
  n++;
  if(n>5) break; // n大於5就停止迴圈
}
```

continue跟break不同之處在於它是停下目前任務，直接進到下一個循環，

```cpp
for(int i=0;i<=10;i++){
  if(i%2==0) continue;
  cout << i << endl;
}
// 只會輸出奇數
```

goto可以在程式中任意跳躍，只要指定好目標就行，

```cpp
start:{
    ...;
    goto Error;
}
Error:{
    ...;
	goto start;
}

```

goto應避免使用，否則會讓程式難以閱讀，而且沒有goto也能寫出相同功能的程式。

---

## 陣列

現在寫個小程式，輸入N，然後輸入N個數字，最後把N個數字顛倒輸出，

如果我們輸入的N達到幾千幾萬，那宣告幾千幾萬個變數太不切實際了。我們其實可以一次宣告很多變數，

宣告方式： `資料型態 名稱[長度];`

這裡的長度需要是編譯時期的常數，像是

```cpp
int a[100];
double b[100];
```

只有在GCC的編譯環境我們可以使用 
```cpp 
int a[n]; 
```

如果要動態宣告，要用到其他資料結構跟動態記憶體宣告，之後會在講指標提到。

再來我們就能使用a[0],a[1],a[2]...a[n-1]當作每個變數了，

在[ ]中的數字，我們稱之為"索引值"，索引值對應的值，稱為"元素"，特別注意，

**索引值是從0開始的，即0代表第1個變數，1代表第2個變數**

宣告完的陣列是沒有初始化的，如果貿然存取會出現無法預測的情況，因此我們可以一次初始化全部元素，

```cpp
int a[100]={0}; // 將這100個元素全部初始化為0
```

或者直接初始化每個陣列值

```cpp
int a[5]={1,5,4,3,2};
```

最後我們可以寫出剛剛那題的程式了

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  int n;
  cin >> n;
  int a[n]; // GCC
  for(int i=0;i<n;i++) cin >> a[i]; //利用上次講的for迴圈輸入每個變數值，注意從0開始
  
  for(int i=n-1;i>=0;i--) cout << a[i] << endl; //倒序輸出，注意最後一個索引值是n-1

}

```

---

## 字元字串

之前提到了字元宣告，但未提及如何利用，現在我們試試這個程式碼：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a='a',b='z';
    for(int i=a;i<=b;i++) cout << i << endl;
}

```

你會發現它輸出了97~122，注意我使用了整數型態，卻用字元初始化，

沒錯，經過型態轉換，'a'會變成97，'z'會變成122，其實這就是ascii碼，因此我們其實可以用字元做計算，
現在可以試試看如果改成'A'~'Z'會對應到哪些ascii碼呢。


字元的宣告要用char，而字串就是字元型態的陣列啦~

，不過這次我們使用在C++比較常用的`string`(字串)來講解，

如果不使用萬能函式庫，必須include \<string>。

string可以這樣宣告

```cpp
string s1; //空字串
string s2("abcde"); //用字面常量宣告初始化
string s3(s2); // 複製s2
string s4 = "edasd"; // 用字面常量宣告初始化
```

string可以用size()或length()直接查看字數(字串長度)，用empty()確認是否是空字串，甚至可以直接用==比較字串內容是否相同，

```cpp
string s1 = "abcde";
string s2;

cout << s1 << endl;
cout << "字串1長度="<<s1.size() << endl;
if(s2.empty()) cout << "字串2是空的" << endl;
else cout << "字串2不是空的" << endl;

s1 = s2;
cout << s2 << endl;
```

因為字串即字元陣列，我們也可以直接使用[ ]存取每個值。


如果要循序走訪，我們可以

```cpp
for(auto i:S){
    cout << i << endl;
}
```

至於原理會在指標中介紹。

---

## 指標

## 函式與遞迴

## 物件

## 簡化程式可讀性

## 高中競技程式之路


