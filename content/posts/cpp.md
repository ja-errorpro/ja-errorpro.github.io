---
title: C++筆記-語法
date: 2021-08-16
tags:
  - C-Cpp
---

*所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主

## 基礎C++模板



附上STL標頭檔：

```cpp
#include<bits/stdc++.h>
```

**注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個**

這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 ``<algorithm>`` 裡的__gcd(計算最大公因數)

不過有些編譯器不包含這個標頭檔，可以自己Google找到對應的解決方法。

有時候看別人的Code還會看到一個標頭檔 ``<bits/extc++.h>`` ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。

為了方便，會在下面定義名稱空間 ``using namespace std;`` ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣在做像是輸入輸出(cin、cout)等操作時
不需要在每個句子前面加上 ``std::`` 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。
打個比喻，如果說標頭檔是圖書館，那std就是你想找的書。

而每個程式都會需要一個叫做main的主函式，這個函式就是整個程式的起點跟終點：
```cpp
int main(){
	return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。
}
```

在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。

注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在C++，"引入標頭檔"這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。

### 總結程式碼(模板)：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout << "Hello World"; // 你會看到電腦跟你說Hello World
	return 0;
}
```


---

## 變數概論

當我們要進行複雜運算時，變數成為很重要的東西，你可以用變數儲存各種資料，讓電腦記住它。

要如何宣告一個變數？格式為 ``(變數型態) (變數名稱)``，我們可以一次宣告很多變數： ``(型態) (名稱),(名稱),(名稱)...;``

ex: ``int a,b,c;``

要注意的是，變數的名稱在同作用範圍下不可重複，只能為英數字、底線(_)、開頭不可為數字、且不能是C++裡面已經定義的名稱(ex:int,char,double,long...)

### 變數型態：

根據型態的不同，儲存所需容量也會不同，依照平台而有所差異，如果想知道該型態佔了多少空間，可以使用sizeof()，
以下所提的空間都是在多數32位元機器上佔有空間

### 一、整數

每種整數資料型態都會有一定的值域，若超過的話會發生溢位，使得答案出錯
而signed/unsigned表示型態含不含符號，而負數前面都會有一個 "-" ，因此當型態為unsigned時，是將所有負值的空間加到正值，讓正值值域更大

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| short/short int | 2 Bytes | -2^15~2^15-1 | 短整數 |
| unsigned short/unsigned short int | 2 Bytes | 0~2^16-1 | 無符號短整數 |
| int/long int/signed/signed long int/long | 4 Bytes | -2^31~2^31-1 | 整數 |
| unsigned int/unsigned long int/unsigned | 4 Bytes | 0~2^32-1 | 無符號整數 |
| long long/long long int | 8 Bytes | -2^63~2^63-1 | 長整數 |
| unsigned long long/unsigned long long int | 8 Bytes | 0~2^64-1 | 無符號長整數 |

### 二、浮點數

就是有小數點的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| float | 4 Bytes | -3.4E38~3.4E38 | 單精度浮點數 |
| double/long double | 8 Bytes | -1.7E308~1.7E308 | 倍精度浮點數 |

**在競技程式中，建議用double為主，因為double在計算上的精準度比float來得高很多。**

### 三、字串與字元

用來儲存文字的東西

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| char | 1 Bytes | 0~277 | 字元 |
| string | 不定 | 每個0~277 | 字串 |

string 其實可以說是字元的組合，在c++它是比char好用的東西，之後會在講陣列/字串操作時提到。

### 四、布林值

用來判斷條件的變數

| 型態 | 空間 | 範圍 | 描述 |
|---------|---------|---------|---------|
| bool | 1 Bytes | 0/1、true/false | 布林值 |

它只能存true(真)或者false(假)，通常用於判斷條件的成立

---

### 作用範圍

我們可以將變數的作用範圍分為 **全域性變數**、**區域性變數**、當然還有**靜態變數**、**常數**

定義：
- 全域性變數：在程式任何地方都可以調用
- 區域性變數：在特定的記憶體範圍中可以調用
- 靜態變數：宣告之後可作為全域性變數使用
- 常數：宣告之後不可再更動其值

這樣說可能還是有點模糊，看看這個程式碼：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int s=0; //s是常數，如果在程式的某個地方修改它的值，會報錯
int a; // a是全域變數，可以在f函式也可以在main裡使用
int f(){
	return 1;
}
int main(){
	static int b; //b是靜態變數，可以拿到main函式以外的地方使用
	int c;// c是區域變數，只能在main裡用
	return 0;
}
```

我們程式是**由上往下**讀的，因此如果在上面程式碼中的f函式、main函式中間再加一個變數m，則這個變數只能在m下面的程式中也就是main函式中調用。

---

### 溢值

試試這支有bug的乘法程式，看看它有沒有符合想要的結果：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a = 100000;
    int b = 400000;
    int mul = a*b;
    cout << mul;//輸出 40000000000
    return 0;
}
```

這是因為int只能儲存$-2147483647\sim2147483647$範圍的值，如果超出範圍，會造成不可預期的結果

### 強制轉換類型

C++具有任意強制轉換變數型態的方法，分成隱式轉換跟強制轉換，兩者差別在前者是由編譯器自動轉換，後者由程式設計師強制轉型

```cpp
int a = 7;
double b = 1.2;
int c = a*b;
```

在這支程式中，編譯器會先把整數a轉成浮點數(小轉大)，計算完後，把結果轉成整數(大轉小)直接去掉小數點後的值再賦值給c
，最後c會是8，這就是隱式轉換。

```cpp
int a = 7;
double b = 1.2;
cout << a*(int)b;
```

這次在b前面加了(int)，是將b先轉成整數再進行運算輸出，此為強制轉換。

## 邏輯與運算子

學程式語言，必定要會的是邏輯與位元運算，  
以下是之後會超常使用的運算子，請熟記它們的功能。  

| 優先度 | 運算子 | 描述 | 閱讀順序 | 例子 |
|---------|---------|---------|---------|---------|
| 1 | :: | 作用域，當你的程式複雜起來再用它，目前暫時都用不到 | -> | std::cout << endl; |
| 2 | ++/\--<br>()<br>[]<br>.<br>-> | 先回傳再加減1<br>函式呼叫\\陣列存取\\物件存取成員\\指標存取成員 | -> | i++/i\--  int a = f(x);<br> int a[10];<br>obj.cmp = 0;<br>ptr->val = 0; |
| 3 | ++/\--<br>+/-<br>!<br>~<br>(Type)<br>\*<br>&<br>sizeof | 先加/減1再回傳<br>正負號<br>邏輯NOT<br>位元取反<br>強制轉換類型<br>指標指向的值<br>指標位址<br>所佔位元組大小 | <- | ++i/\--i<br>+/-1<br>while(!true)<br>a = ~a;<br>int i=int(doublex);<br>int k = \*a;<br>int \*k = &a;<br>cout << sizeof(int);//4 |
| 4 | \*<br>/<br>% | 乘<br>除<br>取模 | -> | int a = 8\*8;<br>int a = 20/6;<br>int a = 6%4; |
| 5 | +/- | 加/減 | -> | int a = 6+4; |
| 6 | >>/<< | 位元右/左移(除/乘2的n次方) | -> | int a = 4 >> 3; |
| 7 | </<=/>/>= | 大小等於 | -> | if(a < 0) |
| 8 | ==/!= | 等於/不等於 | -> | while(a!=0) |
| 9 | & | 位元AND運算 | -> | n = x&1 |
| 10 | ^ | 位元XOR運算 | -> | n = x^1 |
| 11 | \| | 位元OR運算 | -> | n = x\|1 |
| 12 | && | 邏輯AND | -> | if(1==3 && 2==2) |
| 13 | \|\| | 邏輯OR | -> | if(1==3 \|\| 2==2) |
| 14 | c?p1:p2 | 三元條件運算(可當成if-else) | <- | int i = a>b?a:b; |
| 15 | =/+=/-=/\*=//=/%=/<<=/>>=/&=/^=/\|= | 賦值 | <- | a+=3;b&=1; |
| 16 | , | 逗號 | -> | int i,j,k; |

這裡我們先特別關注邏輯運算AND、OR、XOR，  
它們的運算方式都要從二進位表示法來看，  
並一個一個位數來做計算。  

使用AND運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

舉例：

$9_{10}\ \\&\ 8_{10}= 1001_2\ \\&\ 1000_2=1000_2=8_{10}$


可觀察只有當兩位元都是1時輸出才是1。  

我們可以將它應用在判斷奇偶數： 
```cpp
cout << (x&1?"Yes":"No") ;
```

使用OR運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

舉例：  
$ 10_{10}\ |\ 8_{10} = 1010_2\ |\ 1000_2 = 1010_2 = 10_{10} $$

只要有位元為1，則輸出就是1。  

使用XOR運算結果如下：  

| P | Q | 結果 |
|---------|---------|---------|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

舉例：  

$ 10_{10} \oplus 8_{10} = 1010_2 \oplus 1000_2 = 0010_2 = 2_{10} $

兩個位元只能有一個是1，其他情況都回傳0。  

它的用途更廣，你可以用它將兩個數交換：  
```cpp
a^=b;
b^=a;
a^=b;
```

可以判別一個陣列中哪個數缺少：  

```cpp
int a[]={1,2,3,5,6,7,8,9};
int n=0;
for(int i=0;i<9;i++) n^=i;
for(int i=0;i<9;i++) n^=a[i];
cout << n;
```

可以做大小寫轉換：  

```cpp
char tolower(char c){
	return (c>='A'&&c<='Z')?c^32:c;
}
char toupper(char c){
	return (c>='a'&&c<='z')?c^32:c;
}
```  

### 補充 - 巨集：
有時候，我們不想打那麼多字，為節省時間，可以在前面先定義  
一個巨集： `#define`
```cpp
#define int long long 
//讓所有整數都變成長整數，之後用int宣告的話都會宣告成long long
#define pb push_back
//把指令縮短，之後要用就打pb就好
```

有時候如果定義的巨集是變數型態也可以用`typedef`
```cpp
typedef long long ll
//之後宣告long long就打ll就好
```


---

## 輸入/輸出與流Buffer概念

### 流
在c++我們需要了解一下流跟緩衝區的概念，  
C++這個語言本來是沒有IO功能的，  
基本的輸入輸出定義於`<iostream>`與`<fstream>`這兩個標準模板庫(std)裡，  
它們被分成了三個標準：  
istream/ cin、wcin ： 標準輸入流  
ostream/ cout、wcout ： 標準輸出流  
ostream/ cerr、wcerr ： 標準錯誤輸出流(無緩衝)  
ostream/ clog、wclog ： 標準錯誤輸出流(有緩衝)  

輸入的方式，是使用(>>)從輸入流中擷取資料，而輸出則是用(<<)將資料擷取到輸出流。  
這就是一開始學校在教程式時會說輸入就是 `cin >> x;`，輸出是 `cout << x;`，箭號方向不能交換。  

### 緩衝區  
緩衝區的定義是 `用作中介的內存塊`，這樣說可能沒人懂，  
它就是先把資料全部移到一個地方(內存)，再去慢慢讀取的概念。  
因為程式只能一個字一個字讀，如果直接讀，程式會變超慢，   
也就是當程式頻繁進行IO操作，會頻繁把高速的部分打斷，  
造成性能下降。  

緩衝區的功用就在於避開頻繁操作，只要讀取緩衝區的資料就好。  
只有需要時再刷新緩衝區進行IO操作，讓程式性能提升。  

以下狀況會刷新緩衝區：  
* 使用cin  
* 釋放cout的資源
* 使用endl、fflush
* 程式正常結束


關於IO優化等操作，可查閱[算法筆記](./algo)


### 輸入  
在C++，我們使用cin(音：西印)輸入文字，  
方法很簡單，不像C語言還要指定型別， `cin >> x;` 就是輸入資料到x。  
當要輸入多筆資料，只要在後面繼續加就好 `cin >> x >> y >> z;`。  

如果不想使用bits/stdc++.h，需要include \<iostream>

範例程式：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int x;
    cin >> x;
    int y,z;
    cin >> y >> z;
    return 0;
}
```

而cin的好處同時也是壞處就是若輸入空格會自動斷開，  
當想輸入一句話 `This is a Simple Sentence.` 進一個字串，  
如果使用cin，最後字串可能只會存到 `This` 而已。

因此這裡介紹另一種輸入 `getline()`，  
它的功能是直接讀取整行資料，也就是它會連空格一起讀進去，  
直到換行為止。  

```cpp
getline(cin,s,' ') //getline(輸入流, 字串,切割字元(可以不填))
```
注意這個函式只能輸入字串。  

輸入完後通常要將字串切成好幾份資料，  
這時就會用到字串流 `stringstream`  
可以把它想成另一種cin，只是它必須存字串。
如果不使用bits/stdc++.h，則要include \<sstream>才能使用stringstream  
```cpp
string s;
getline(cin,s);
stringstream ss(s); //初始化s放到字串流裡
```

然後就可以去切割它了，用陣列把這些資料儲存起來。  
這裡使用到stol()可以將字串轉成整數。

```cpp
string s,t;
getline(cin,s);
stringstream ss(s);
int a[1000],i=0;
while(getline(ss,t,' ')){
	a[i++] = stol(t);
}
```

### 輸出

在最一開始的[模板](#總結程式碼模板)，就可以看到輸出的方法了(cout)，
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int x;
    cin >> x;
	cout << x;
    int y,z;
    cin >> y >> z;
	cout << y << " " << z << endl;
    return 0;
}
```

關於endl，
上面只說到它會刷新緩衝流，而其實它全名叫endline，即換行。

### 補充

Q:如果使用cerr輸出會發生什麼事？

cerr是用來除錯的，注意有些Judge不會把它當成輸出，你可以用來測試你的程式哪裡寫錯



---

## 字面常數

程式中的0,1,1.1都叫字面常數，代表程式的符號，

整型字面常數包含2,8,10,16進位，其中2進位是C++14才加入的

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int base10 = 1234; // 十進位
    int base8 = 0373; // 八進位
    int base16 = 0xf1; // 十六進位
    int base2 = 0b1010; // 二進位
}
```

對於整數，cout都會以十進位輸出，試試看輸出上面程式中的變數會出現什麼數值。

有時要做運算時可能發現直接使用數字計算，編譯器會報錯，比如要某個型態為long long的值加上10，這時可以在10後面加上LL，編譯器就會把10看作long long型態計算了。

對於浮點數，有很方便的科學記號，1000000000可以寫成1e9，0.0008可以寫成8e-4。











