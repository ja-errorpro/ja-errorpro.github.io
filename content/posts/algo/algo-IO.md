---
title: 算法筆記-常數優化
tags: 
  - algorithms
---

* [算法筆記目錄](/posts/1/algo-index/)

## 編譯器優化
我們的程式變成執行檔時需要經過一連串的轉譯與運算，  
如果改變編譯器的編譯模式，或者改變寫程式的習慣，有可能會讓效率變更高。

一般的Judge編譯器模式都是O2，是個比較安全的運算方式。  
但其實我們可以在程式中再加入一些指令，改變編譯器的運算方式。  

```cpp
#pragma GCC optimize("Ofast") 
//以較不安全的運算來編譯程式
#pragma loop_opt(on) 
//迴圈優化
#pragma comment(linker,"/stack:200000000")
//更改最大堆疊數
```

以上是我常用的編譯器優化指令，

請注意不是所有OJ都支援pragma優化。

## I/O優化

當我們比較cout、cin與printf、scanf時，會發現後者比前者快非常多。  
這是因為每次在輸入輸出前，程式會將資料放進一個緩衝區(內存)，然後再從內存裡拿出。  
我們應該減少拿取的動作，因為這非常耗時。

如果做過CF互動題，會發現題目會要求在輸出後加上cout.flush()，就是要把資料強制輸出，  
否則它可能要等到程式結束後才輸出。  

cin，它的原理其實是讀取鍵盤輸入的字，再輸出給使用者看打了什麼，  
這就讓拿取的動作暴增了，解決方法是加上 `cin.tie(0);`  
讓內存強制釋放掉。

C++有兩種輸出輸入，分別是stdio與iostream，而程式可能會搞混而發生問題  
，使得效率變差，這時就加上 `ios_base::sync_with_stdio(false);` 就解決了  
加上這行後，之後的輸入輸出就是選(cin,cout)或(scanf,printf)其中一個，  
絕對不要再混用。

C++的換行可以是endl或'\n'，而其實 `cout << endl` 相當於 `cout << '\n' << flush`  
也就是它順便把內存清空了，做了多餘的動作。  
之後記得要換行的話就用'\n'別再用endl了。 ~~或放個 `#define endl '\n'`~~

---