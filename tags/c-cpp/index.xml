<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C-Cpp on ErrorPro</title><link>/tags/c-cpp/</link><description>Recent content in C-Cpp on ErrorPro</description><generator>Hugo 0.125.1</generator><language>zh-Hant-TW</language><lastBuildDate>Thu, 25 May 2023 00:00:00 +0800</lastBuildDate><atom:link href="/tags/c-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>【CPE】2023-05-23 紀錄</title><link>/posts/2023/cpe_20230523/</link><pubDate>Thu, 25 May 2023 00:00:00 +0800</pubDate><guid>/posts/2023/cpe_20230523/</guid><description>CPE(大學程式能力檢定) 第一次考CPE，考前沒時間準備所以基本上就是裸考。
隨便寫寫，做了4題
pA - UVA11934 題意： 給你一個二次函數、一個除數 $d$ 及 $L$，求 $f(0)$ 到 $f(L)$ 的值有幾個可被 $d$ 整除
$-1000 \le a,b,c \le 1000, 1&amp;lt;d&amp;lt;10^6, 0 \le L &amp;lt; 1000$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define int long long #define endl &amp;#39;\n&amp;#39; int f(int a, int b, int c, int x) { return a * x * x + b * x + c; } signed main() { int a, b, c, d, L; while (cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d &amp;gt;&amp;gt; L) { if (a == 0 &amp;amp;&amp;amp; b == 0 &amp;amp;&amp;amp; c == 0 &amp;amp;&amp;amp; d == 0 &amp;amp;&amp;amp; L == 0) break; int ans = 0; for (int i = 0; i &amp;lt;= L; i++) { if (f(a, b, c, i) % d == 0) ans++; } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } } pB - UVA11349 題意： 給一個方矩陣問是否為對稱矩陣。</description></item><item><title>中原111資工計概下學期期中機測</title><link>/posts/2023/cycu_cal_1112_midterm/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0800</pubDate><guid>/posts/2023/cycu_cal_1112_midterm/</guid><description>Pre 題目提供以下資料結構與函式
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #include &amp;lt;ctype.</description></item><item><title>中原111資工計概上學期期末機測</title><link>/posts/2023/cycu_cal_111_finalexam/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0800</pubDate><guid>/posts/2023/cycu_cal_111_finalexam/</guid><description>答案僅供參考 答案僅供參考 答案僅供參考 我看起來像標準答案嗎 Pre 題目提供以下資料結構與函式
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 # include &amp;lt;stdlib.</description></item><item><title>中原111資工計概上學期期中機測</title><link>/posts/2022/cycu_cal111_midterm/</link><pubDate>Mon, 07 Nov 2022 00:00:00 +0800</pubDate><guid>/posts/2022/cycu_cal111_midterm/</guid><description>(本人已放棄思考) 答案僅供參考 答案僅供參考 答案僅供參考 鬼才知道是不是正解 pA 實作NotLetter(char ch) function，如果ch不是字母就回傳true，反則false。
1 2 3 4 5 6 7 bool NotLetter(char ch){ if(ch &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;z&amp;#39;) return false; if(ch &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;Z&amp;#39;) return false; return true; } 補：事實上在 ctype.h已經有 isalpha() 可使用，但這裡不允許include其他東西。
pB 實作MonotonicIncreasing() function，讀入若干個整數，直到-99999，如果數組(不含-99999)非單調遞增則回傳false，否則或如果只有一個數則回傳true。
1 2 3 4 5 6 7 8 9 10 11 12 bool MonotonicIncreasing(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); while(n!=-99999){ int m; scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); if(m &amp;lt; n &amp;amp;&amp;amp; m !</description></item><item><title>VSCode設定C++教學(Code Runner)</title><link>/posts/2022/vscode_cpp_setup/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0800</pubDate><guid>/posts/2022/vscode_cpp_setup/</guid><description>遇到很多來問我VSC怎麼設定C/C++的問題，這裡直接寫篇文來說明我的作法。
前置 環境(以撰寫此篇文時的環境為主)： Windows 11(64 bit) 22H2 Visual Studio Code 1.71 7-Zip 目標 配置GCC 12 MinGW-w64 不含Clang 之編譯器 成功在VSCode裡編譯並執行一支C/C++程式 過程 一、安裝延伸模組： C/C++、Code Runner 二、下載編譯器：範例為GCC 12.2.0 + MinGW-w64 10.0.0 without Clang 請到這個網站
下載編譯器(視個人需求選擇一種編譯器)，並解壓到任意空間，(ex: C:/)
三、設定環境變數 Windows設定 -&amp;gt; 系統 -&amp;gt; 裝置規格 -&amp;gt; 進階系統設定 -&amp;gt; 環境變數 -&amp;gt; 系統變數(使用者環境變數)
在變數名 Path 中添加路徑(剛剛解壓到的路徑/bin/)
完成後打開cmd(命令提示字元)或Terminal，輸入 gcc -v，如果成功的話就會在最後一行看到 gcc version 12.1.0 字樣。
四、設定VSCode 打開VSCode，點擊左下角齒輪，然後找到右上角功能欄中的 開啟設定(JSON)，在最外面的{}裡貼上以下範例設定
1 2 3 4 5 6 7 &amp;#34;code-runner.executorMap&amp;#34;:{ &amp;#34;c&amp;#34;: &amp;#34;cd $dir &amp;amp;&amp;amp; gcc $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&amp;#34;, &amp;#34;cpp&amp;#34;: &amp;#34;cd $dir &amp;amp;&amp;amp; g++ -std=c++11 -O2 $fileName -o $fileNameWithoutExt &amp;amp;&amp;amp; $dir$fileNameWithoutExt&amp;#34; }, // 編譯並執行指令，其中設定項 -std= 後面可接C++版本 (98,11,14,17,20,.</description></item><item><title>C++筆記-(補充)巨集</title><link>/posts/cpp/cpp-macro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-macro/</guid><description> C++筆記-目錄 補充 - 巨集： 有時候，我們不想打那麼多字，為節省時間，可以在前面先定義
一個巨集： #define
1 2 3 4 #define int long long //讓所有整數都變成長整數，之後用int宣告的話都會宣告成long long #define pb push_back //把指令縮短，之後要用就打pb就好 我們也可以用巨集來定義函式：
1 2 #define add(a,b) a+b //定義一個函式，參數為a,b，回傳a+b 有時候如果定義的巨集是變數型態也可以用typedef
1 2 typedef long long ll //之後宣告long long就打ll就好 定義陣列巨集：
1 2 3 4 typedef char str[100]; //之後宣告字串就打str就好 str s; // 宣告 char 陣列</description></item><item><title>C++筆記-IO</title><link>/posts/cpp/cpp-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-io/</guid><description>C++筆記-目錄 輸入/輸出與流Buffer概念 流 在c++我們需要了解一下流跟緩衝區的概念，
C++這個語言本來是沒有IO功能的，
基本的輸入輸出定義於&amp;lt;iostream&amp;gt;與&amp;lt;fstream&amp;gt;這兩個標準模板庫(std)裡，
它們被分成了三個標準：
istream/ cin、wcin ： 標準輸入流
ostream/ cout、wcout ： 標準輸出流
ostream/ cerr、wcerr ： 標準錯誤輸出流(無緩衝)
ostream/ clog、wclog ： 標準錯誤輸出流(有緩衝)
輸入的方式，是使用(&amp;raquo;)從輸入流中擷取資料，而輸出則是用(&amp;laquo;)將資料擷取到輸出流。
這就是一開始學校在教程式時會說輸入就是 cin &amp;gt;&amp;gt; x;，輸出是 cout &amp;lt;&amp;lt; x;，箭號方向不能交換。
緩衝區 緩衝區的定義是 用作中介的內存塊，簡單來說，
它就是先把資料全部移到一個地方(內存)，再去慢慢讀取的概念。
因為程式只能一個字一個字讀，如果直接讀，程式會變超慢，
也就是當程式頻繁進行 IO 操作，會頻繁把高速的部分打斷，
造成性能下降。
緩衝區的功用就在於避開頻繁操作，只要讀取緩衝區的資料就好。
只有需要時再刷新緩衝區進行 IO 操作，讓程式性能提升。
以下狀況會刷新緩衝區：
使用cin 釋放cout的資源 使用endl、fflush 程式正常結束 關於 IO 優化等操作，可查閱算法筆記
輸入 在 C++，我們使用 cin(音：西印) 輸入文字，
方法很簡單，不像 C 語言還要指定型別， cin &amp;gt;&amp;gt; x; 就是輸入資料到x。
當要輸入多筆資料，只要在後面繼續加就好 cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;。</description></item><item><title>C++筆記-函式與遞迴</title><link>/posts/cpp/cpp-function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-function/</guid><description>C++筆記-目錄 函式與遞迴 之前有在講變數作用範圍時偷偷寫了一個函式，現在將會說明如何使用。
到目前，我們都只用到main函式而已，假設我們有需要重複使用的程式碼，可以寫成函式，
只要丟參數進去，就能得到傳回值。
先以最基礎的線性函數(y=ax+b)開始，可以這樣寫
1 2 3 int f(int x){ return a*x+b; } 只要我們帶x進去，函式就會傳回計算後的值，使用函式的過程稱為呼叫
1 2 3 cout &amp;lt;&amp;lt; f(0) &amp;lt;&amp;lt; endl; int y = f(2); cout &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; 而函式可以選擇接受或不接受參數，也能自訂型態
1 2 3 4 void f(){ // 不接受參數 可以做任何事; return; // 使用void就不會回傳值 } 而上一章字串介紹的empty()，其實也是一個布林函式
1 2 3 4 bool empty(){ if (字串沒東西) return true; else return false; } 而遞迴就是函式自己呼叫自己而已，
現在利用遞迴概念，我們試著寫寫看計算階乘(n乘到1)的函式
1 2 3 4 5 long long f(int n){ //計算 n!</description></item><item><title>C++筆記-增加程式可讀性</title><link>/posts/cpp/cpp-simplify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-simplify/</guid><description> C++筆記-目錄 簡化程式可讀性 現在基礎語法已經學得差不多了，現在來談談如何讓別人更容易看懂自己的程式，之後若跟別人合寫也讓人比較容易除錯。
我認為要讓人容易看懂自己的程式碼，有以下幾點需要注意
善用註解，說明邏輯 變數名稱取名有意義的文字會更好 如果有沒有用到的函式、變數就不用多寫 可以在每次操作完輸出變數檢查 避免跳來跳去的結構，像是goto 重複的程式碼可以濃縮成函式或迴圈</description></item><item><title>C++筆記-字元字串</title><link>/posts/cpp/cpp-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-string/</guid><description>C++筆記-目錄 字元字串 之前提到了字元宣告，但未提及如何利用，現在我們試試這個程式碼：
1 2 3 4 5 6 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int a=&amp;#39;a&amp;#39;,b=&amp;#39;z&amp;#39;; for(int i=a;i&amp;lt;=b;i++) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } 你會發現它輸出了97~122，注意我使用了整數型態，卻用字元初始化，
沒錯，經過型態轉換，&amp;lsquo;a&amp;rsquo;會變成97，&amp;lsquo;z&amp;rsquo;會變成122，其實這就是ascii碼，因此我們其實可以用字元做計算， 現在可以試試看如果改成&amp;rsquo;A&amp;rsquo;~&amp;lsquo;Z&amp;rsquo;會對應到哪些ascii碼呢。
字元的宣告要用char，而字串就是字元型態的陣列啦~
，不過這次我們使用在C++比較常用的string(字串)來講解，
如果不使用萬能函式庫，必須include &amp;lt;string&amp;gt;。
string可以這樣宣告
1 2 3 4 string s1; //空字串 string s2(&amp;#34;abcde&amp;#34;); //用字面常量宣告初始化 string s3(s2); // 複製s2 string s4 = &amp;#34;edasd&amp;#34;; // 用字面常量宣告初始化 string可以用size()或length()直接查看字數(字串長度)，用empty()確認是否是空字串，甚至可以直接用==比較字串內容是否相同，
1 2 3 4 5 6 7 8 9 10 string s1 = &amp;#34;abcde&amp;#34;; string s2; cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;字串1長度=&amp;#34;&amp;lt;&amp;lt;s1.</description></item><item><title>C++筆記-字面常數</title><link>/posts/cpp/cpp-literal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-literal/</guid><description>C++筆記-目錄 字面常數 程式中的 0, 1, 1.1 都叫字面常數，代表程式的符號，
整型字面常數包含 2, 8, 10, 16 進位，其中 2 進位是 C++14 才加入的
1 2 3 4 5 6 7 8 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int base10 = 1234; // 十進位 int base8 = 0373; // 八進位 int base16 = 0xf1; // 十六進位 int base2 = 0b1010; // 二進位 } 對於整數，cout 都會以十進位輸出，試試看輸出上面程式中的變數會出現什麼數值。
有時要做運算時可能發現直接使用數字計算，編譯器會報錯，比如要某個型態為 long long 的值加上 10，這時可以在 10 後面加上 LL，編譯器就會把 10 看作 long long 型態計算了。</description></item><item><title>C++筆記-指標</title><link>/posts/cpp/cpp-pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-pointer/</guid><description>C++筆記-目錄 指標 觀念 現在我們要寫一個交換兩個數的函式，如果這樣寫會發生什麼事呢
1 2 3 4 5 6 7 8 9 10 11 12 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; void swap(int x,int y){ int t=x;x=y;y=t; } int main(){ int a=1,b=2; swap(a,b); cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; return 0; } Output: 1 2
奇怪，ab沒有被交換，
其實，這程式相當於我們又宣告了xy並交換xy，ab跟xy並沒有關係，這時我們就需要用到指標了。
要取得變數的指標，只需在它前面加上 &amp;amp; 就好，如果我們輸出 &amp;amp;a，會得到它的記憶體位址。
而指標的型態，取決於它從哪種變數取得指標，int指標型別就是 int*，double指標型別是double*
宣告指標的方式也很簡單
1 2 int a; int *b = &amp;amp;a; // *放在靠int或是靠變數名稱都可以 上面程式代表b是a的指標
如果不初始化指標，建議將值設為0或者nullptr(空指標)，避免造成不可預期的結果</description></item><item><title>C++筆記-未定義行為</title><link>/posts/cpp/cpp-ub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-ub/</guid><description>C++筆記-目錄 未定義行為(Undeﬁned Behavior，簡稱 UB) 有時我們執行程式時，會發現程式的行為不是我們預期的，有時候就是未定義行為惹的禍。
一些例子 1. 順序未定義 考慮以下程式碼：
1 2 int i = 10; i = i++ + ++i; 這段的程式碼最後 i 值無法預期，因為沒有規定 i++ 和 ++i 哪個先執行，不一樣的編譯器可能會有不同的結果。
而像以下程式碼也是錯誤的寫法
1 2 3 int arr[10]; int i = 0; arr[i] = i++; 2. 除以零 1 2 int a = 5; int q = a / 0; 除以零是未定義行為，而在 float、double、long double 類型除以零的結果，根據 IEEE 754，可能是 inf 或 nan(Not A Number)。
3. 溢值 1 2 int x = 2147483647; // 假設 32 位元 int y = x + 1; 4.</description></item><item><title>C++筆記-流程控制</title><link>/posts/cpp/cpp-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-process/</guid><description>C++筆記-目錄 流程控制 選擇結構 藉由前面那些知識，可以做出基本的運算跟輸出輸入了，現在我們可以給程式&amp;quot;做選擇&amp;quot;，實現更多功能。
題目：
輸入一個正整數，如果他是偶數則輸出Yes，否則輸出No。 這時我們可以使用 if(如果)， 用法：
1 2 3 if(條件式(condition) ){ //當條件成立要做的事 } 而這題的寫法如：
1 2 3 4 5 6 7 8 9 10 11 12 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int n; cin &amp;gt;&amp;gt; n; if(n%2==0){ // 當 n 除以 2 的餘數為0 cout &amp;lt;&amp;lt; &amp;#34;Yes&amp;#34; &amp;lt;&amp;lt; endl; } if(n%2!=0){ // 當 n 除以 2 的餘數不為0 cout &amp;lt;&amp;lt; &amp;#34;No&amp;#34; &amp;lt;&amp;lt; endl; } } 在條件式中，我們判斷 n % 2 是否等於 0，% 是取模運算符號，又稱取餘數， n % 2 意思是 n 除以 2 的餘數。</description></item><item><title>C++筆記-浮點數</title><link>/posts/cpp/cpp-float/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-float/</guid><description>C++筆記-目錄 浮點數 名言：「算錢用浮點，遲早被人扁。」 浮點數是一個很難理解的東西，
這裡特別拿出來說明。
宣告 如果遇到一定要用浮點數的情況，請使用 double 或 long double 的型態，
不要使用 float！ 不要使用 float！ 不要使用 float！ IEEE 754 與浮點數誤差 現在還沒有完整的方式可以存一個實數，目前電腦的儲存方式是採用 IEEE 754 標準
IEEE 754
IEEE754是自20世紀80年代以來現代電腦最廣泛使用的浮點數運算標準，除了浮點數的表示以外，它還定義了關於負0、反常值以及其運算子與例外情況，像是inf(Infinite)、nan(Not A Number)這些特殊數值。
我們要先知道如何做進制轉換， 欲將十進位轉成二進位，對於整數部分，就是一直除以2直到商數為0，再依序由下往上取出餘數：
而小數則相反，需要一直乘以2直到變成0為止，且每次的運算都只取小數部分，再依序由上往下取出整數。
假設要轉換 432.1 為二進制，
計算 結果 餘數 432/2 216 0 216/2 108 0 108/2 54 0 54/2 27 0 27/2 13 1 13/2 6 1 6/2 3 0 3/2 1 1 1/2 0 1 由下往上寫結果就是 110110000
對小數部分</description></item><item><title>C++筆記-物件(結構體)</title><link>/posts/cpp/cpp-struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-struct/</guid><description>C++筆記-目錄 物件(結構體) Struct 現在我們要幫銀行寫一個管理系統，管理每個帳戶的資料，資料要含有：名字、身分證號、戶籍地、性別、出生年月日、存額。
我們發現每個資料需要的型態好像不一樣，不適合用陣列，但要存的資料數量卻都一樣， 這時我們可以建立一種物件了，其實就是自訂資料型態！
1 2 3 4 5 6 7 8 struct Account{ // 建立&amp;#34;帳戶&amp;#34;這個型態 string name; // 名字 string ID; // 身分證號 string Living; // 戶籍地 bool gender; // 性別(大多數情況就男女之分(? 所以用bool) long long birthday; // 出生日期 long long balance; // 帳戶餘額 }; //要分號 這樣，我們就能把它當成一種型態來操作了，假設要開新帳戶：
1 Account a; 如果要存取帳戶內容，
1 2 3 a.name = &amp;#34;吉娃娃&amp;#34;; a.ID = &amp;#34;A12345678&amp;#34;; ... 當然如果有很多帳戶，也能直接宣告陣列
1 2 Account Arr[100]; Arr[0].name = &amp;#34;吉娃娃&amp;#34;; 我們也可以在結構體裡宣告函式，比如計算一點跟它自己的距離：</description></item><item><title>C++筆記-目錄</title><link>/posts/cpp-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp-index/</guid><description>所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主 運作原理與基礎模板 變數 邏輯與運算子 浮點數 巨集(補充) IO 字面常數 流程控制 陣列 字串 函式與遞迴 指標 物件(結構體) 簡化程式可讀性 未定義行為 Reference Openhome</description></item><item><title>C++筆記-語法</title><link>/posts/cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/</guid><description>*所有內容將以Windows 10+,MinGW-w64 GNU 8.1.0 C++17為主
程式碼運作原理 我們知道其實電腦只懂0與1，因此想跟電腦溝通就需要透過一些轉譯，
在人類的世界中所使用的語言叫高階語言，而只由0與1數字組成的語言稱為機器語言，我們很難看懂，
要將高階語言轉成機器語言，就需要藉由編譯器與組譯器的幫忙，編譯器可以幫我們把程式碼轉成所謂的組合語言，此時階段
就會有很多人開始看不懂了，當然如果有學過還是能稍微看懂，但組合語言經過組譯器就會變成0跟1，只有電腦才看得懂。
基礎C++模板 附上STL標頭檔：
1 #include&amp;lt;bits/stdc++.h&amp;gt; 注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個
這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 &amp;lt;algorithm&amp;gt; 裡的__gcd(計算最大公因數)
不過有些編譯器不包含這個標頭檔，可以自己Google找到對應的解決方法。
而在只有輸入輸出這些簡單的程式中，我們使用 &amp;lt;iostream&amp;gt; 就好
1 #include &amp;lt;iostream&amp;gt; 有時候看別人的Code還會看到一個標頭檔 &amp;lt;bits/extc++.h&amp;gt; ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。
為了方便，會在下面定義名稱空間 using namespace std; ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫std的名稱空間裡，這樣在做像是輸入輸出(cin、cout)等操作時 不需要在每個句子前面加上 std:: 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。 打個比喻，如果說標頭檔是圖書館，那std就是你想找的書。
而每個程式都會需要一個叫做main的主函式，這個函式就是整個程式的起點跟終點：
1 2 3 int main(){ return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。 } 在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。
注意到，有些程式句後面加了分號有些卻沒有，這是C++中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在C++，&amp;ldquo;引入標頭檔&amp;quot;這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。
總結程式碼(模板)： 1 2 3 4 5 6 #include&amp;lt;iostream&amp;gt; using namespace std; int main(){ cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 你會看到電腦跟你說Hello World return 0; } 註解 在上面兩個程式碼中，會看到裡面寫了 // 後面接上說明，稱為&amp;quot;註解&amp;rdquo;，註解的內容不會被編譯器讀取，註解有兩種模式： 單行註解及多行註解，在C++裡的語法是這樣的</description></item><item><title>C++筆記-變數</title><link>/posts/cpp/cpp-variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-variable/</guid><description>C++筆記-目錄 變數概論 當我們要進行複雜運算時，變數成為很重要的東西，你可以用變數儲存各種資料，讓電腦記住它。
要如何宣告一個變數？格式為 (變數型態) (變數名稱)，我們可以一次宣告很多變數： (型態) (名稱),(名稱),(名稱)...;
ex: int a,b,c;
要注意的是，變數的名稱在同作用範圍下不可重複，只能為英數字、底線(_)、開頭不可為數字、且不能是C++裡面已經定義的名稱(ex:int, char, double, long&amp;hellip;)
變數型態： 根據型態的不同，儲存所需容量也會不同，依照平台而有所差異，如果想知道該型態佔了多少空間，可以使用 sizeof()， 以下所提的空間都是在多數 32 位元機器上佔有空間
一、整數 integer 每種整數資料型態都會有一定的值域，若超過的話會發生溢位，使得答案出錯 而 signed/unsigned 表示型態含不含符號，而負數前面都會有一個 &amp;ldquo;-&amp;rdquo; ，因此當型態為 unsigned 時，是將所有負值的空間加到正值，讓正值值域更大
型態 空間 範圍 描述 short/short int 2 Bytes -2^15~2^15-1 短整數 unsigned short/unsigned short int 2 Bytes 0~2^16-1 無符號短整數 int/long int/signed/signed long int/long 4 Bytes -2^31~2^31-1 整數 unsigned int/unsigned long int/unsigned 4 Bytes 0~2^32-1 無符號整數 long long/long long int 8 Bytes -2^63~2^63-1 長整數 unsigned long long/unsigned long long int 8 Bytes 0~2^64-1 無符號長整數 二、浮點數 float 就是有小數點的變數</description></item><item><title>C++筆記-運作原理與基礎模板</title><link>/posts/cpp/cpp-init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-init/</guid><description>C++筆記-目錄 程式碼運作原理 我們知道其實電腦只懂 0 與 1，因此想跟電腦溝通就需要透過一些轉譯，
在人類的世界中所使用的語言叫高階語言，而只由 0 與 1 數字組成的語言稱為機器語言，我們很難看懂，
要將高階語言轉成機器語言，就需要藉由編譯器與組譯器的幫忙，編譯器可以幫我們把程式碼轉成所謂的組合語言，此時階段
就會有很多人開始看不懂了，當然如果有學過還是能稍微看懂，但組合語言經過組譯器就會變成0跟1，只有電腦才看得懂。
基礎C++模板 附上STL標頭檔：
1 #include&amp;lt;bits/stdc++.h&amp;gt; 注意，比競程時再用他，如果是其他用途(大型專案)的話最好是不要引入這個
這個標頭檔包含了之後會使用到的任何輸入輸出、資料結構，還藏有很多很方便的函式像是 &amp;lt;algorithm&amp;gt; 裡的 __gcd(計算最大公因數)
不過有些編譯器不包含這個標頭檔，可以自己 Google 找到對應的解決方法。
而在只有輸入輸出這些簡單的程式中，我們使用 &amp;lt;iostream&amp;gt; 就好
1 #include &amp;lt;iostream&amp;gt; 有時候看別人的Code還會看到一個標頭檔 &amp;lt;bits/extc++.h&amp;gt; ，那是內建紅黑樹、雜湊表的標頭檔等更進階的東西，現在暫時不理他。
為了方便，會在下面定義名稱空間 using namespace std; ，為什麼要加這個？因為我們需要將程式的幾乎所有東西都被定義到一個叫 std 的名稱空間裡，這樣在做像是輸入輸出 (cin, cout) 等操作時 不需要在每個句子前面加上 std:: 這種東西，也就是這段程式是起到了類似宣告成了全域變數的作用。 打個比喻，如果說標頭檔是圖書館，那 std 就是你想找的書。
而每個程式都會需要一個叫做 main 的主函式，這個函式就是整個程式的起點跟終點：
1 2 3 int main(){ return 0; // 函式結束後，要使用這句話回傳一個值，來告訴程式已經執行完了。 } 在這裡就是將main函式宣告成int(整數)，因此結束後也要回傳一個整數才行，而它也可以被宣告為signed(我習慣宣告成這個)，這個等下會提到。
注意到，有些程式句後面加了分號有些卻沒有，這是 C++ 中規定的，以分號作為一段程式的結束(句點)，而當在引入標頭檔以及有大括號時則不需要分號，因為在 C++，&amp;ldquo;引入標頭檔&amp;quot;這個行為就是以換行為這段程式碼的結束。同樣地，只要編譯器讀完大括號，就算是將這裡面的東西執行完了。
Cout cout 是程式的嘴巴，負責讓電腦說話，只要使用 &amp;lt;&amp;lt; 把文字傳給 cout 後，程式就會說出你給的台詞！</description></item><item><title>C++筆記-邏輯與運算子</title><link>/posts/cpp/cpp-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-operator/</guid><description>C++筆記-目錄 表達式 Expression 有人常言道：「表達式(計算式)的天職，就是得到一個值。」
1 + 2 是一個表達式，其中 1 是一個運算元，2 是另一個運算元，而 + 是運算子。
1 + ( 2 - 3 ) 也是一個表達式，這個表達式裡還有一個表達式 ( 2 - 3 )，稱為複合表達式(Compound Expression)
而等等會看到的 a = 5，其實也是一個表達式，將 5 賦值給 a，那麼這個表達式得到的值當然就是最後賦值給 a 的數值。
運算子 Operator 運算子可簡單區分為一元(單元)運算子、二元運算子以及三元運算子。
每個運算子都有執行的優先順序，如同數學有先乘除後加減，以下是之後可能會在 c++ 看到的運算子：
優先度 運算子 描述 閱讀順序 例子 1 :: 作用域 -&amp;gt; std::cout &amp;laquo; endl; 2 ++/-- () [] . -&amp;gt; 先回傳再加減1 \ 函式呼叫 \ 陣列存取 \ 物件存取成員 \ 指標存取成員 -&amp;gt; i++/i--; int a = f(x); int a[10]; obj.</description></item><item><title>C++筆記-陣列</title><link>/posts/cpp/cpp-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/cpp/cpp-array/</guid><description>C++筆記-目錄 陣列 現在寫個小程式，輸入N，然後輸入N個數字，最後把N個數字顛倒輸出，
如果我們輸入的N達到幾千幾萬，那宣告幾千幾萬個變數太不切實際了。我們其實可以一次宣告很多變數，
宣告方式： 資料型態 名稱[長度];
這裡的長度需要是編譯時期的常數，像是
1 2 int a[100]; double b[100]; 只有在GCC的編譯環境我們可以使用
1 int a[n]; 如果要動態宣告，要用到其他資料結構跟動態記憶體宣告，之後會在講指標提到。
再來我們就能使用a[0],a[1],a[2]&amp;hellip;a[n-1]當作每個變數了，
在[ ]中的數字，我們稱之為&amp;quot;索引值&amp;quot;，索引值對應的值，稱為&amp;quot;元素&amp;quot;，特別注意，
索引值是從0開始的，即0代表第1個元素，1代表第2個元素，n-1代表第n個元素 如果貿然存取未初始化或超出陣列索引範圍的地方會出現無法預測的情況
參考：C++筆記-未定義行為
剛剛宣告完的陣列是沒有初始化的，
我們可以一次初始化全部元素，
1 int a[100]={0}; // 將這100個元素全部初始化為0 或者直接初始化每個陣列值
1 int a[5]={1,5,4,3,2}; 如果我們只初始化前面幾個元素，剩下的元素會自動初始化為0
1 2 int a[5]={1,5,4}; // a[0]=1,a[1]=5,a[2]=4,a[3]=0,a[4]=0 最後我們可以寫出剛剛那題的程式了
1 2 3 4 5 6 7 8 9 10 11 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ int n; cin &amp;gt;&amp;gt; n; int a[n]; // GCC for(int i=0;i&amp;lt;n;i++) cin &amp;gt;&amp;gt; a[i]; //利用上次講的for迴圈輸入每個變數值，注意從0開始 for(int i=n-1;i&amp;gt;=0;i--) cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; endl; //倒序輸出，注意最後一個索引值是n-1 } 如果要宣告二維陣列存更多東西，其實就是每個元素都是一個陣列</description></item></channel></rss>