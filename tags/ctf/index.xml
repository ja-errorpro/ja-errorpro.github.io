<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ctf on ErrorPro</title><link>/tags/ctf/</link><description>Recent content in ctf on ErrorPro</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>【系統安全】Linux 安全機制</title><link>/posts/2023/linux_system_security/</link><pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate><guid>/posts/2023/linux_system_security/</guid><description>Address space layout randomization(ASLR): 記憶體隨機載入，會把.stack section, .so section, mmap()隨機化，可以防止攻擊者跳到指定記憶體任意利用
繞過：目前沒有很好的繞過方法，只能靠運氣猜記憶體在哪
Stack Canary: 金絲雀，在以前礦工在挖礦的時候會帶一隻金絲雀下去，如果金絲雀暈倒表示可能挖到有毒氣體了，要趕快跑，在程式裡面也會有這樣的機制，每次執行一個函數會先養一隻金絲雀(一個隨機數)，如果攻擊者傷害到那隻金絲雀(覆寫掉隨機數)就表示受到攻擊，程式在函式離開前檢查到就會直接停止
繞過：只要不碰到金絲雀，或推算出金絲雀長什麼樣子就能繞過
No-eXecute(NX): 堆疊不可執行，把記憶體的stack標記為不可執行，可以防止攻擊者跳到堆疊任意寫程式
繞過：不要跳到stack，那跳到text就好了
PIE(Position Independent Executable): 記憶體隨機化，跟ASLR很像，但是是在編譯器上做好，會把.text section, .data section, .bss section隨機化
繞過：讓程式執行的過程中洩露記憶體然後就能推算
程式實際位址 = 程式加載位址 + 偏移位址
Fortify Source: 在編譯時檢查是否存在buffer overflow，並將危險函式替換成安全函式，例如strcpy()會被替換成strncpy()
RELRO(RELocation Read-Only): 在Lazy Binding時，會將.got.plt section設為read-only，可以防止攻擊者修改.got.plt section</description></item><item><title>【系統安全】組合語言</title><link>/posts/2023/asm/</link><pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate><guid>/posts/2023/asm/</guid><description>組合語言 編譯流程 詞法分析 (Lexical Analysis) 切token -&amp;gt; 詞素 (Lexeme)
語法分析 (Syntax Analysis) 建立語法樹 (Syntax Tree)
語意分析 (Semantic Analysis) 用語法樹跟符號表 (Symbol Table) 來檢查語意
中間碼產生 (Intermediate Code Generation)
最佳化 (Optimization)
目標碼產生 (Code Generation)
GCC編譯流程 前置處理 (Preprocessing) -&amp;gt; 編譯 (Compilation) -&amp;gt; 組譯 (Assembly) -&amp;gt; 連結 (Linking) 檔案副檔名 (.i) (.s) (.o) (.out) 指令參數 -E -S -c 前置處理 (Preprocessing) 遞迴處理所有 #include 遞迴展開所有 #define 刪除所有註解 處理所有 #if #ifdef #ifndef #else #endif 行號記錄 編譯 (Compilation) 組語格式：預設 AT&amp;amp;T 語法，可用 -masm=intel 改成 Intel 語法</description></item><item><title>【CTF-WriteUp】PicoCTF-Here's a LIBC</title><link>/posts/2023/ctf_picoctf_heresalibc/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>/posts/2023/ctf_picoctf_heresalibc/</guid><description>題目：
給你指定的libc與elf file請pwn掉它 概念： 組合語言課學的各種東西 逆向工程 Little endian stack frame ELF format ret2libc 題解： 執行 file 查看檔案屬性 這是一個64位ELF格式可執行檔
執行 checksec 查看安全屬性 只開了 NX(No-Execute, 堆疊不可執行)
拿去Ghidra或IDA逆向 看起來會用到的函式：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 char convert_case(char c, int f){ char ret; if( c &amp;lt; &amp;#39;a&amp;#39; || c &amp;gt; &amp;#39;z&amp;#39; ){ if( c &amp;lt; &amp;#39;A&amp;#39; || c &amp;gt; &amp;#39;Z&amp;#39; ) ret = a; else if(f % 2 == 0) ret = a; else ret = a + 32; } else if( f % 2 == 0 ) ret = a - 32; else ret = a; return ret; } void do_stuff(){ char garbage; char str[112]; scanf(&amp;#34;%[^\n]&amp;#34;, str); scanf(&amp;#34;%c&amp;#34;, &amp;amp;garbage); for(int i = 0; i &amp;lt; 100 ; i++){ str[i] = convert_case(str[i], i); } puts(str); } void main(){ .</description></item><item><title>【CTF】Metasploitable3 環境建置(Windows VMware)</title><link>/posts/2022/metasploitable3_installation/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate><guid>/posts/2022/metasploitable3_installation/</guid><description>需求 Windows 10 up VMware Workstation Pro 良好的網路環境 1. 下載並安裝 Vagrant &amp;amp; Vagrant VMware Utility Vagrant 是建置虛擬機的工具，透過 Vagrantfile 來設定虛擬機。
Download Vagrant
Download Vagrant VMware Utility
2. 快速建置 打開 PowerShell，cd 到適當的資料夾，依序輸入
1 2 3 4 mkdir metasploitable3-workspace cd metasploitable3-workspace Invoke-WebRequest -Uri &amp;#34;https://raw.githubusercontent.com/rapid7/metasploitable3/master/Vagrantfile&amp;#34; -OutFile &amp;#34;Vagrantfile&amp;#34; vagrant up --provider=vmware_desktop 等待一段時間，完成後可以在
C:\Users\{username}\.vagrant.d\boxes\xxx\yyy\vmware_desktop\ 下看到 box 檔案。
將 vmware_desktop 資料夾複製到適當的地方，接著打開 VMWare，在 Library 下按右鍵點選 Scan for Virtual Machines，選擇剛剛複製的資料夾，就可以使用 Metasploitable3 了。</description></item><item><title>【CTF】Metasploitable2 滲透測試實作(筆記)</title><link>/posts/2022/metasploitable2_vsftpd/</link><pubDate>Wed, 23 Nov 2022 00:00:00 +0000</pubDate><guid>/posts/2022/metasploitable2_vsftpd/</guid><description>先備知識 知道如何使用 VMware 或 VirtualBox Kali Linux 基本操作 能夠讓 Kali 連線至 Metasploitable2 Metasploitable2 一種充滿漏洞的Linux系統，適合用於練習滲透測試。
可直接到 Sourceforge 上下載虛擬機檔。
偵查 開啟 Metasploitable2，會先要求輸入帳號密碼，帳密都是 msfadmin (輸入密碼時不會顯示在螢幕上)。
輸入 ifconfig 查看 IP 位址，假設為 192.168.235.130。
打開 Kali Linux (IP為192.168.235.128)，終端輸入 msfconsole 進入 Metasploit。
使用 nmap 掃描可以連的 port 1 msf6 &amp;gt; nmap -sV 192.168.235.130 可以看到有一大堆 port 是開著的
滲透 看看 vsftpd 有沒有洞，在 msf 中輸入 search vsftpd，可以看到有一個 exploit 可以使用 使用這個 exploit，用 show options 可以看到這個 exploit 需要的參數，然後用 set 參數 值 設定一些參數。 1 2 3 msf6 &amp;gt; use exploit/unix/ftp/vsftpd_234_backdoor msf6 exploit(unix/ftp/vsftpd_234_backdoor) &amp;gt; show options msf6 exploit(unix/ftp/vsftpd_234_backdoor) &amp;gt; set RHOSTS 192.</description></item><item><title>【CTF-WriteUp】PicoCTF-file-run2</title><link>/posts/2022/ctf_picoctf_file_run2/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate><guid>/posts/2022/ctf_picoctf_file_run2/</guid><description>題目：
給你一個檔案，執行它時輸入&amp;quot;Hello!&amp;quot;(不含引號)。 概念： 逆向工程 Linux 指令操作 Linux 權限控制 題解 丟進IDA看看，發現確實只要輸入Hello!就能跑出Flag，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 main(int param_1,long param_2){ int var1; if ((param_1 &amp;lt; 2) || (2 &amp;lt; param_1)) { puts(&amp;#34;Run this file with only one argument.&amp;#34;); } else { var1 = strcmp(*(char **)(param_2 + 8),&amp;#34;Hello!&amp;#34;); if (var1 == 0) { printf(&amp;#34;The flag is: %s&amp;#34;,flag); } else { puts(&amp;#34;Won\&amp;#39;t you say \&amp;#39;Hello!</description></item><item><title>gdb 除錯工具學習</title><link>/posts/2022/gdb/</link><pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><guid>/posts/2022/gdb/</guid><description>What is GDB? gdb全名為gnu debugger，是一種動態Debug的工具。
使用 我們可以先寫一個簡易的Hello World，並宣告一些變數
1 2 3 4 5 6 7 8 # include&amp;lt;stdio.h&amp;gt; int main(){ int a = 5; int b = a * 6; int c = b + 4; printf(&amp;#34;Hello World\n&amp;#34;); return 0; } 記得在編譯時加上參數 -g，否則gdb將提示找不到除錯符，加了只差在程式大小會變大。
1 2 $ gcc -g hello.c -o hello $ gdb ./hello 指令 指令 簡寫 簡述 help h 查看指令說明 list l 印出程式碼 file 開啟檔案 run r 執行程式 kill 停止程式 breakpoint b, bre, break 設定斷點 ex: b 15表示執行到第15行 continue c, cont 繼續執行 next n 步過(遇到呼叫函式會將該函式當成一條指令執行) step s 步入(遇到呼叫函式會進入函式一步一步執行) print p 印出變數的值 ex: p num display 每次步過/入後印出變數值 ex: display num info 查看特定資訊 ex: info break查看設了哪些斷點，不輸入參數可查詢指令 quit q 離開gdb，或按Ctrl+C &amp;lt;Click&amp;gt; Enter 執行上一條指令</description></item><item><title>【CTF-WriteUp】EasyCTF-adder</title><link>/posts/2022/ctf_easyctf_adder/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><guid>/posts/2022/ctf_easyctf_adder/</guid><description>題目：
給你一個加法程式，找出Flag adder
概念： 反編譯 題解 在linux執行程式，看到要你輸入三個數，先隨意輸入，發現輸出nope。
開啟反編譯工具Ghidra對檔案反編譯，發現在main函式中的flag前綴，
而只要讓該行上面的if條件成立應該就能得到flag，顯然我們只要輸入三個數讓他加起來等於 0x539 即可。
透過簡單的進位換算，得$539_{16}\ =\ 1337_{10}$
開啟程式輸入1337 0 0 就可以拿到flag了~</description></item></channel></rss>