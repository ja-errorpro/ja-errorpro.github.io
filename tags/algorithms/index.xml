<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithms on ErrorPro</title><link>/tags/algorithms/</link><description>Recent content in algorithms on ErrorPro</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 25 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>【CPE】2023-05-23 紀錄</title><link>/posts/2023/cpe_20230523/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>/posts/2023/cpe_20230523/</guid><description>CPE(大學程式能力檢定) 第一次考CPE，考前沒時間準備所以基本上就是裸考。
隨便寫寫，做了4題
pA - UVA11934 題意： 給你一個二次函數、一個除數 $d$ 及 $L$，求 $f(0)$ 到 $f(L)$ 的值有幾個可被 $d$ 整除
$-1000 \le a,b,c \le 1000, 1&amp;lt;d&amp;lt;10^6, 0 \le L &amp;lt; 1000$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define int long long #define endl &amp;#39;\n&amp;#39; int f(int a, int b, int c, int x) { return a * x * x + b * x + c; } signed main() { int a, b, c, d, L; while (cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d &amp;gt;&amp;gt; L) { if (a == 0 &amp;amp;&amp;amp; b == 0 &amp;amp;&amp;amp; c == 0 &amp;amp;&amp;amp; d == 0 &amp;amp;&amp;amp; L == 0) break; int ans = 0; for (int i = 0; i &amp;lt;= L; i++) { if (f(a, b, c, i) % d == 0) ans++; } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } } pB - UVA11349 題意： 給一個方矩陣問是否為對稱矩陣。</description></item><item><title>中原111資工計概下學期期中機測</title><link>/posts/2023/cycu_cal_1112_midterm/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>/posts/2023/cycu_cal_1112_midterm/</guid><description>Pre 題目提供以下資料結構與函式
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #include &amp;lt;ctype.</description></item><item><title>中原111資工計概上學期期末機測</title><link>/posts/2023/cycu_cal_111_finalexam/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>/posts/2023/cycu_cal_111_finalexam/</guid><description>答案僅供參考 答案僅供參考 答案僅供參考 我看起來像標準答案嗎 Pre 題目提供以下資料結構與函式
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 # include &amp;lt;stdlib.</description></item><item><title>中原111資工計概上學期期中機測</title><link>/posts/2022/cycu_cal111_midterm/</link><pubDate>Mon, 07 Nov 2022 00:00:00 +0000</pubDate><guid>/posts/2022/cycu_cal111_midterm/</guid><description>(本人已放棄思考) 答案僅供參考 答案僅供參考 答案僅供參考 鬼才知道是不是正解 pA 實作NotLetter(char ch) function，如果ch不是字母就回傳true，反則false。
1 2 3 4 5 6 7 bool NotLetter(char ch){ if(ch &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;z&amp;#39;) return false; if(ch &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;Z&amp;#39;) return false; return true; } 補：事實上在 ctype.h已經有 isalpha() 可使用，但這裡不允許include其他東西。
pB 實作MonotonicIncreasing() function，讀入若干個整數，直到-99999，如果數組(不含-99999)非單調遞增則回傳false，否則或如果只有一個數則回傳true。
1 2 3 4 5 6 7 8 9 10 11 12 bool MonotonicIncreasing(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); while(n!=-99999){ int m; scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); if(m &amp;lt; n &amp;amp;&amp;amp; m !</description></item><item><title>【TIOJ】1903-你的笑容由我來守護-EXTREME</title><link>/posts/2022/tioj1903/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>/posts/2022/tioj1903/</guid><description>題目： 給一張$N$個點的無向圖，一開始有$M$條邊。 接著$Q$個操作，有以下兩種：
增加一條連著$A_i$、$B_i$的邊。 刪除一條連著$A_i$、$B_i$的邊(保證這條邊存在)。 每次操作完後輸出當前連通塊數量。
$1 \le N \le 5e5$ $M+Q \le 5e5$ $0 \le A_i,B_i \le N-1$ $A_i \neq B_i$ 輸入： 第一行有一個數字T代表測資筆數。
每筆測資第1行有3個整數N、M、Q。
接下來M行每行兩個整數Ai、Bi，代表Ai和Bi這兩個人目標相同。
接下來Q行，每行有一個字元 c 和兩個整數Ai、Bi，代表修改一個紀錄。
如果 c 是 N，代表增加一筆 Ai、Bi 兩人目標相同的紀錄；
如果 c 是 D，代表要刪除一筆 Ai、Bi 目標相同的紀錄，所有刪除都是合法的。
輸出： 對於每筆測資的Q筆修改，每次修改完輸出一行代表連通塊數量。
Ex 1 Input: 2 3 0 3 N 0 1 N 1 2 N 2 1 3 3 3 0 1 1 2 2 1 D 2 1 D 0 1 D 2 1 Ex 1 Output: 2 1 1 1 2 3 題解： 動態維護連通塊數量可以使用並查集(DSU)，但多了刪除的操作。</description></item><item><title>103年彰雲嘉P5 - Infix to Postfix</title><link>/posts/2021/mtwcp103_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp103_5/</guid><description>題目： 一般我們在表示運算式時，是使用中序式，是將運算子放在兩運算元中間， 比如 (A+B)*(C+D)。而在電腦中，需要將中序式轉成後序式以方便運算。 (A+B)*(C+D)的後序式為 AB+CD+*； A*(B+C)-D*E+F 的後序式為 ABC+*DE*-F+ 。 請寫一程式將中序式轉成後序式。 輸入： 輸入一個中序運算式，其中運算元為A~Z等26個單一字母表示，運算子只包含+、-、*、/。 運算式中可有任意多個括號，且保證輸入的式子合法。 輸出： 輸出後序式。 Ex 1 Input: 中置式: (A+B*(C-D)+E)* ((F+G)/(H*I)+J) Ex 1 Output: 後置式: ABCD-*+E+FG+HI*/J+* 題解： 需要注意的是四則運算的優先序(括號先算，由左到右，先乘除，後加減)。
這題是非常經典的堆疊資料結構應用題，用 getline 輸入，遇到運算子就加入堆疊，
先看括號，然後看加減乘除，如果遇到 ) 的話，就把堆疊的運算子都輸出直到碰到 ( 為止。
而運算元則直接輸出就行。
(我的編譯器因為格式問題輸出不了中文&amp;hellip;反正程式碼對就好)
這問題可以再延伸，比如以中序式進行四則運算輸出結果，
跟這題做法很像只要把中序轉成後序然後讀一遍，
遇到運算子就把前面讀到的數字做運算後放入堆疊，注意運算子可能有多位數。
補充：這種需要stack的題目通常能用遞迴完成，因為遞迴本身就是一種堆疊。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>107年彰雲嘉p3 - GCD &amp; LCM</title><link>/posts/2021/mtwcp107_3/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_3/</guid><description>題目： 給你一堆數字(&amp;gt;=0)，求他們的GCD(最大公因數)與LCM(最小公倍數) 輸入： 一堆數字以空格分開，最後以0結束 輸出： 所有數字(除了0以外)的GCD跟LCM，以空格分開 Ex 1 Input: 10 20 30 0 Ex 2 Input: 3 5 7 9 12 0 Ex 3 Input: 100 100 200 0 Ex 1 Output: 10 60 Ex 2 Output: 1 1260 Ex 3 Output: 100 200 題解： 就是一題簡單的數論題， 可以根據歐幾里得算法 gcd(a,b-a) = gcd(a,b mod a), gcd(a,0) = |a| (輾轉相除)來求GCD， 那LCM要怎麼求？我們知道 a | (a*b) 且 b | (a*b) (a*b必為ab公倍數) 如果要得到最小公倍數，只要除以gcd(a,b)就行。
當我們在計算mod時，要注意有沒有負數問題，因為C++的算法會使負數模運算出差錯， 建議使用((a%b)+b)%b 來取代 a%b，這樣就能簡單避開負數取模的問題了。 還好這題輸入並沒有負數，但之後做模運算時請稍加注意。</description></item><item><title>107年彰雲嘉P6 - 統一發票對獎程式</title><link>/posts/2021/mtwcp107_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp107_6/</guid><description>題目： Ex 1 Input: 73372972 22315462 91903003 16228722 03270598 163 983 814 73372971 22315461 91903001 16228722 13210598 03210163 0 Ex 1 Output: 201200 題解： 前三個獎直接判別，後面判別如果你用int，就 mod pow(10,i)；
如果你用字串，直接複製 string s1(s.begin()+i,s.end())。
這裡使用字串判別。
判定順序可以任意，總之記得符合條件就一定要break不然會多算。
增開六獎跟持有號碼數量雖然不一定，但他們長度都是固定的，
string直接s.size()，而int你可以透過除以1000 == 0? 判別。
這裡直接把六獎當增開六獎判定，反正結果一樣。
官方測資的獎金不會超過$2^{31}$，所以不會溢位。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉上午P5 - 魔術三角形</title><link>/posts/2021/mtwcp108_1_5/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_5/</guid><description>題目： 魔術三角形是一個由1到9的數字所形成之三角形， 每邊由4個數字組成，邊與邊之間會有1個數字共用，而且每個邊 4個數字相加之總和是一樣的，舉例來說，下圖是一個魔術三角形，三個邊的數字和均為19。 我們以三角形最上面的數字7為起點，順時針方向列出所有9個數字來表示這個三角形， 表示為&amp;quot;781359264&amp;quot; (取自108年彰雲嘉資訊科能力競試上午場P5)
預先將下圖的三個藍色粗框部分填入數字，請填入其餘數字使其成為一個魔術三角形。 (取自108年彰雲嘉資訊科能力競試上午場P5)
輸入： 三個1~9之間的數代表依順時針填入藍色粗框的3個數字。 輸出： 將形成的魔術三角形之9個數字合併成一個十進位數字輸出，若存在多個答案 ，則輸出十進位數字最小者。若無法形成魔術三角形，則輸出1個0。 Ex 1 Input: 4 3 6 Ex 2 Input: 4 6 7 Ex 1 Output: 542937168 Ex 2 Output: 249561873 題解： 題目沒給時間限制，當然直接暴力做下去啊！
時間複雜度也只有O(6!) = O(720)，
所以也不會超過1秒
可使用next_permutation()這個函式，
他是用來枚舉排列的工具，既然是排列，
有學過排列組合都知道不重複排列數是P(n,n)
那時間複雜度就會是O(P(n,n))=O(n!)
如果遇到排列數很多的就還是別用了吧
記得在用這個函式時要先把要排的數組先排序好，
才能完整枚舉所有排列。
上程式碼：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉上午P6 - Knight Moves</title><link>/posts/2021/mtwcp108_1_6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_1_6/</guid><description>題目： 西洋棋騎士/象棋的馬每步可以沿日字對角走到另一對角， 現在有一個X*Y的棋盤，左下角座標(0,0)，右下為(X-1,0) 棋子的起始點為(a,b)，請求出走到(c,d)的最小步數。 其中X,Y&amp;lt;=10000 輸入： 本題有多筆測資，第一行輸入N代表有幾筆測資 接下來每筆測資有一行， 依序以空格分開輸入6個正整數X, Y, a, b, c, d 輸出： 針對每筆測資依序輸出最短步數 Ex 1 Input: 2 10 10 3 4 7 6 10 10 3 4 9 9 Ex 1 Output: 2 5 題解： 如果還是不懂騎士走法可參考 維基百科
這題是非常經典的最短路問題，可使用BFS(廣度優先搜尋)解。
可以想像有一個確診武漢肺炎的同學坐在班上位置中間，
而病毒就從那位同學開始往旁邊擴散，
每過一天就一個確診，
最後全班都被感染病毒，
然後就能求哪位同學會在第幾天確診。
其原理是利用佇列(&amp;lt;queue&amp;gt;)，造訪所有圖上的位置，
並記錄從起點到每個位置一共走了多少步。
騎士走法是按照日字走的，因此可推論一個點會有八種走法
而步數就是上一個點的步數再+1
上程式碼(當然你可以用struct建立點佇列，就不用宣告那麼多queue跟陣列了)：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma loop_opt(on) #include&amp;lt;bits/stdc++.</description></item><item><title>108年彰雲嘉下午P10 - Huffman</title><link>/posts/2021/mtwcp108_2_10/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/2021/mtwcp108_2_10/</guid><description>題目： Huffman ： 維基百科
霍夫曼樹經常被用來作資料壓縮，將字串資料轉成霍夫曼碼以減少字串資料所佔的空間大小，其詳細作法如下： (1)字串中所有的字母元素都放在最底層的葉節點上，節點中的值為此字母的出現次數。 (2) 每次從尚無父節點的所有節點中，尋找值最小（出現次數最少）的兩個節點來建立霍夫曼樹， 產生其父節點的值為兩個節點值相加的和。最後只剩下根節點沒有父節點。 (3) 從根節點開始往下編碼，左分支為 0，右分支為 1，每個葉節點的字母元素會產生一個霍夫 曼碼（由 0 和 1 所組成），字母元素出現的頻率越高則霍夫曼碼越短。 我們這題需要計算一個字串轉成霍夫曼碼的壓縮率。假設有個字串&amp;quot;queue&amp;quot;，則此字串會佔5 bytes = 40bits空間， 轉成霍夫曼碼後應為&amp;quot;00011011&amp;quot;，只需要8個bits就可儲存，因此壓縮率為(40-8)/40 * 100% = 80%。 輸入： 輸入一列字串(長度最多100字元，且不含空格)。 輸出： 依序輸出此字串壓縮前的bit數、壓縮後的bit數、壓縮率百分比(格式為⌊n⌋%，即n向下取整)。 Ex 1 Input: queue Ex 2 Input: abadcafcabfdec Ex 3 Input: aaaaaaamcmhhhhhmkkkkkkkkmbbmdddddddmyymppppp Ex 4 Input: BCBBB Ex 1 Output: 40 8 80% Ex 2 Output: 112 35 68% Ex 3 Output: 352 132 62% Ex 4 Output: 40 5 87% 題解： 題目沒說字串中大小寫是否要算成同一字母，因此先視為不同的來處理。</description></item><item><title>算法筆記-DP-LIS</title><link>/posts/1/algo-dp-lis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-dp-lis/</guid><description>算法筆記目錄 最長遞增子列(Longest Increasing Subsequence) 考慮以下問題：
給一個序列，求一個最長的遞增子序列，如 [1,3,2,2,4,0] 中，最長的遞增子序列為 [1,3,4] 或 [1,2,4]。
定義狀態： $dp_i$ 代表掃到第$i$個數時的LIS長度
轉移式： $dp_i = max(dp_j\ | j&amp;lt;i \land a_j&amp;lt;i) + 1$ 表示當發現$a_j &amp;lt; a_i$，則LIS長度+1
邊界狀況： 最小的遞增子列至少為1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Top-Down #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int MAXN = 1005 int a[MAXN],dp[MAXN]; int DP(int i){ if(dp[i]&amp;gt;0) return dp[i]; dp[i] = 1; for(int j=0;j&amp;lt;i;++j) if(a[j]&amp;lt;a[i]) dp[i] = max(dp[i],DP(j)+1); return dp[i]; } int main(){ int n; cin &amp;gt;&amp;gt; n; for(int i=0;i&amp;lt;n;++i) cin &amp;gt;&amp;gt; a[i]; int ans = 0; for(int i=0;i&amp;lt;n;++i) ans = max(ans,DP(i)); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Buttom-Up #include&amp;lt;bits/stdc++.</description></item><item><title>算法筆記-初階資料結構</title><link>/posts/1/algo-primary-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-primary-structure/</guid><description>算法筆記目錄 初階資料結構 1.Segment Tree - 線段樹 Segment Tree是一種二元樹，適合解決RMQ問題(查詢區間極值)、區間和， 適合用於單點修改、區間修改。
成功實現Sparse Table做不到的事。
每個節點可以存一種區間的數據(比如區間和)，
根節點存[1,n]的數據，每個左子節點編號是index*2，右邊為index*2+1，
左邊紀錄[l,(l+r)/2)，右邊紀錄[(l+r)/2+1,r]。
通常，線段樹會開4倍大
1 int T[4*N],a[N]; // int T[N&amp;lt;&amp;lt;2]; 建立線段樹，若l==r，此節點即a[l] 子樹建完後就把資料合併
1 2 3 4 5 6 7 8 9 10 11 void build(int l,int r,int index){ if(l==r){ T[l] = a[l]; } else{ int mid = l+(r-l)/2; // 避免 (l+r)/2 溢位 build(index*2,l,mid); // build(index&amp;lt;&amp;lt;1,l,mid); build(index*2+1,mid+1,r); T[index] = T[index*2] + T[index*2+1] ; } } 詢問區間(ql,qr:要查的區間 l,r:此節點儲存的左右界) 1 2 3 4 5 6 7 8 int query(int ql,int qr,int l,int r,int index){ if(ql&amp;lt;=l &amp;amp;&amp;amp; qr&amp;gt;=r) return T[index]; int mid = l+(r-l)/2; int rt=0; if(ql&amp;gt;mid) rt+=query(ql,qr,mid+1,r,index*2+1); if(qr&amp;lt;=mid) rt+=query(ql,qr,l,mid,index*2); return rt; } 單點修改 1 2 3 4 5 6 7 8 9 void modify(int l,int r,int pos,int index,int val){ if(l==r){ T[index] = val;return; } int mid = l+(r-l)/2; if(pos&amp;lt;=mid) modify(l,mid,pos,index*2,val); else modify(mid+1,r,pos,index*2+1,val); T[index] = T[index*2]+T[index*2+1]; } 懶人標記 如果想在[l,r]中的所有元素加值怎麼辦？ 不可能一個一個呼叫modify吧。</description></item><item><title>算法筆記-基本資料結構</title><link>/posts/1/algo-basic-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-basic-structure/</guid><description>算法筆記目錄 基礎資料結構 我們程式想儲存東西有很多種方式，而資料結構就像一種容器，
可以儲存或拿取需要的東西，每種資料結構都有不同的複雜度，
如果用得好，效率就會高。
以下都是最基本的資料結構
1.Vector - 向量 in &amp;lt;vector&amp;gt; 1 vector&amp;lt;int&amp;gt; v; 向量可當成陣列來用，應該說它就是更強的陣列，而且易維護。
比起原本陣列，它可以自動擴大容量，
能用的空間也比陣列還多。但要注意的是，如果使用operator[]存取了未配置的記憶體位置，
會導致Segmentation Fault。
以下為vector的功能： -- vector[n] 存取索引值為n的元素 -- vector.at(n) 存取索引值為n的元素(較安全) -- vector.begin() 回傳指向vector第一個元素的疊代器 -- vector.end() 回傳指向vector最後一個元素再下一個的疊代器 -- vector.front() 回傳vector[0] -- vector.back() 回傳vector最後一個元素的值 -- vector.size() 回傳目前vector儲存了多少元素 -- vector.resize(n) 修改vector大小 -- vector.capacity() 存取可容納最大個數 -- vector.empty() 回傳布林值表示vector是不是空的 -- vector.reserve(n) 配置更多記憶體以容納更多元素 -- vector.push_back(n) 把n放到vector最尾端 -- vector.pop_back() 把vector最尾端元素取出 -- vector.insert(it,n) 在疊代器it後插入元素n -- vector.erase(it,(it2)) 刪除疊代器it~it2的元素 -- vector.clear() 刪除所有元素 -- vector.</description></item><item><title>算法筆記-常數優化</title><link>/posts/1/algo-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-io/</guid><description>算法筆記目錄 編譯器優化 我們的程式變成執行檔時需要經過一連串的轉譯與運算，
如果改變編譯器的編譯模式，或者改變寫程式的習慣，有可能會讓效率變更高。
一般的Judge編譯器模式都是O2，是個比較安全的運算方式。
但其實我們可以在程式中再加入一些指令，改變編譯器的運算方式。
1 2 3 4 5 6 #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) //以較不安全的運算來編譯程式 #pragma loop_opt(on) //迴圈優化 #pragma comment(linker,&amp;#34;/stack:200000000&amp;#34;) //更改最大堆疊數 以上是我常用的編譯器優化指令，
請注意不是所有OJ都支援pragma優化。
I/O優化 當我們比較cout、cin與printf、scanf時，會發現後者比前者快非常多。
這是因為每次在輸入輸出前，程式會將資料放進一個緩衝區(內存)，然後再從內存裡拿出。
我們應該減少拿取的動作，因為這非常耗時。
如果做過CF互動題，會發現題目會要求在輸出後加上cout.flush()，就是要把資料強制輸出，
否則它可能要等到程式結束後才輸出。
cin，它的原理其實是讀取鍵盤輸入的字，再輸出給使用者看打了什麼，
這就讓拿取的動作暴增了，解決方法是加上 cin.tie(0);
讓內存強制釋放掉。
C++有兩種輸出輸入，分別是stdio與iostream，而程式可能會搞混而發生問題
，使得效率變差，這時就加上 ios_base::sync_with_stdio(false); 就解決了
加上這行後，之後的輸入輸出就是選(cin,cout)或(scanf,printf)其中一個，
絕對不要再混用。
C++的換行可以是endl或&amp;rsquo;\n&amp;rsquo;，而其實 cout &amp;lt;&amp;lt; endl 相當於 cout &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; flush
也就是它順便把內存清空了，做了多餘的動作。
之後記得要換行的話就用&amp;rsquo;\n&amp;rsquo;別再用endl了。 或放個 #define endl '\n'</description></item><item><title>算法筆記-排序</title><link>/posts/1/algo-sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-sorting/</guid><description>算法筆記目錄 排序 排序是將一串資料依優先度排列，是電腦工程最常見且最基本的算法，將資料排序後，可以更有效率的搜尋資料，也可以更有效率的處理資料，利於統計。
氣泡排序(Bubble Sort) 氣泡排序通常是我們在學校會學到的第一種排序法，原因是其簡單易懂，
原理是逐一比較相鄰兩元素，若順序錯誤則交換。
每一輪都確保最後一筆資料在正確的位置。
因此我們需要跑好幾輪，直到整個數組都是正確的順序。
如果數組長度為 $n$，則需要跑 $n-1$ 輪、每輪跑 $n-i$ 次，總共跑 $n(n-1)/2$ 次。
因此時間複雜度為 $O(n^2)$。
1 2 3 4 5 6 7 8 9 void bubbleSort(int arr[], int n) { for (int i = 0; i &amp;lt; n - 1; i++) { for (int j = 0; j &amp;lt; n - i - 1; j++) { if (arr[j] &amp;gt; arr[j + 1]) { swap(arr[j], arr[j + 1]); } } } } 然而氣泡排序法的時間複雜度太高了(成本太高)，如果資料達到數百萬筆就不適合使用此排序法。</description></item><item><title>算法筆記-數論</title><link>/posts/1/algo-number-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-number-theory/</guid><description>算法筆記目錄 什麼是數論 數學的分支，專門研究整數的性質。
模運算 同餘 $a \equiv b \pmod n $ 表示 $n\ |\ (a-b)$ ( $n$ 整除 $a-b$ )，稱 $a$ 與 $b$ 模 $n$ 同餘。
比如
7 除以 3 餘 1
10 除以 3 餘 1
則可以說 $7 \equiv 10 \pmod 3$
證明: 對於 $a \equiv b \pmod k $
令 $a = ks + r,\ b = kt + r$
兩式相減得 $a-b = k(s-t)$
證明結束
加乘法性質 如果 $a \equiv b \pmod n $, $c \equiv d \pmod n $</description></item><item><title>算法筆記-時間複雜度概述</title><link>/posts/1/algo-runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-runtime/</guid><description>算法筆記目錄 時間複雜度在競程中是個非常重要且最基本的工具，
係用於估算程式執行N次，大概需要花多久時間。
我們在程式中做的任何事情可能都需要花費1單位時間，
比如五則運算、條件判斷、變數存賦等。
而我們通常會使用函式$O(Big-O)$ 來表示程式的複雜度。
對於$O()$，有以下定義：
$$ Def:\
\qquad If\ f(x) = O(g(x)),\ ∃M,x_0 &amp;gt; 0,\ such \ that \ ∀x&amp;gt;=x_0,then \ |f(x)| &amp;lt;= M|g(x)| $$
為什麼我們需要估時間複雜度？
因為我們在寫程式追求的是速度！當你的演算法太慢(時間複雜度太大)時，
就算結果是對的，但你會在Online Judge上或APCS得到一個TLE(Time Limit Exceeded)，
即若將測資丟到你的程式，會超出該題目所規定的執行時間。
要如何估自己的程式會跑幾秒？
通常，Judge的執行速度大約是1e8筆/秒，因此只要將題目的範圍限制代入所估複雜度，
然後除以1e8，就能大概知道自己程式會不會TLE了。
常見的複雜度有： $1,n,n^2,n^3,nlogn,2^n$。 而log通常以2為底但我們不太會去明指以誰為底。
以下是複雜度計算的原則：
&amp;ndash; 1.常數倍數不計( $O(2n) = O(n) = O(3n)$ )。
&amp;ndash; 2.若將程式分成兩段複雜度為$O(f(n)),\ O(g(n))$,總複雜度就取複雜度比較大的那段。
即$O(f(n)+g(n)) = O(f(n)) &amp;gt; O(g(n)) ? O(f(n)) : O(g(n))$
&amp;ndash; 3.若有一段程式複雜度為$O(f(n))$執行$g(n)$次，總複雜度是$O(f(n)*g(n))$。</description></item><item><title>算法筆記-枚舉與搜尋</title><link>/posts/1/algo-enum-and-searching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-enum-and-searching/</guid><description>算法筆記目錄 枚舉與搜尋 枚舉(Enumeration) 枚舉，就是把全部或部分可能的情況都列出來，然後一個一個檢查是否符合條件，又稱窮舉。
雖然枚舉通常沒辦法在短時間內解決整個問題，但可以透過解決小問題來找到大問題的規律，或是用於檢驗時間複雜度較低的做法是否正確。
例題一 給一正整數 $n$，求 $n$ 的所有因數。
我們枚舉所有不超過 $n$ 的正整數，檢查每個數字是否為 $n$ 的因數，時間複雜度為 $O(n)$。
1 2 3 4 5 6 7 long long n; cin &amp;gt;&amp;gt; n; for (long long i = 1; i &amp;lt;= n; i++) { if (n % i == 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } } 這個方法雖然確實可以求出所有因數，但效率不夠好，考慮 $n$ 的因數都不會超過 $\sqrt{n}$，所以我們只需要枚舉到 $\sqrt{n}$ 即可，時間複雜度 $O(log\ n)$。
1 2 3 4 5 6 7 8 9 10 long long n; cin &amp;gt;&amp;gt; n; for (long long i = 1; i * i &amp;lt;= n; i++) { if (n % i == 0) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; if (i * i !</description></item><item><title>算法筆記-目錄</title><link>/posts/algo-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/algo-index/</guid><description> 時間複雜度概述 速度優化 排序 基礎資料結構 枚舉與二分搜尋 群論 數論 初階資料結構 貪心</description></item><item><title>算法筆記-群論</title><link>/posts/1/algo-group-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-group-theory/</guid><description>算法筆記目錄 群 有一個集合 $G$ 和一個二元運算子 $\cdot$，滿足以下條件，就稱 $(G,\cdot)$ 構成一個群：
封閉性 對於 $G$ 中的任意兩個元素 $a,b$，都有 $a\cdot b\in G$。 結合性 對於 $G$ 中的任意三個元素 $a,b,c$，都有 $a\cdot (b\cdot c)=(a\cdot b)\cdot c$。 單位元 對於 $G$ 中的任意元素 $a$，都有存在一個元素 $e$，使得 $a\cdot e=a=e\cdot a$。 逆元 對於 $G$ 中的任意元素 $a$，都有存在一個元素 $a^{-1}$，使得 $a\cdot a^{-1}=a^{-1}\cdot a=e$。 以加法為例，$a,b,c \in \mathbb{Z} $，$a+b+c$ 滿足上述條件，因此 $(\mathbb{Z},+)$ 構成一個群。
而因為 $+$ 滿足結合性，所以我們在做運算時不需要加括號，如果 $+$ 運算都與同一元素有關，可以變成乘法，$a+a+a=3a$
注意到群沒有必要滿足交換性，而如果群滿足交換性，則稱為交換群或阿貝爾群。
加法的逆元是負號，乘法的逆元是倒數。
如果 $G$ 中存在一個元素 $g$ 使得對 $G$ 中的任意元素 $a$ 都有 $a = g^n $，則稱 $(G,\cdot)$ 為循環群，也說 $G$ 由 $g$ 生成、$g$ 是 $G$ 的生成元，記作 $G = \langle g \rangle$，其中 $\langle g \rangle$ 稱為 $g$ 的生成集合(Span)。</description></item><item><title>算法筆記-貪心</title><link>/posts/1/algo-greedy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/1/algo-greedy/</guid><description>算法筆記目錄 貪心 貪心就是在每一步都選擇當下看起來最好的選擇，直到結束。
經典題如：換錢問題、排程問題都是貪心的典型題目。
在之後的圖論中如最小生成樹、最短路徑問題也都是利用貪心解。</description></item></channel></rss>