<!-- layouts/shortcodes/cf-secret.html -->
{{ $slug := .Get "slug" }} {{ $workerUrl := .Get "url" | default
"https://secure-content-worker.err0rpro.workers.dev" }}

<div class="cf-secret-container" id="secret-{{ $slug }}">
  <div class="cf-secret-lock">
    <h3 class="secret-title">ðŸ”’</h3>
    <p class="secret-desc"></p>
    <div class="cf-input-group">
      <input
        type="password"
        id="pass-{{ $slug }}"
        placeholder="è¼¸å…¥å¯†é‘°"
        onkeypress="if(event.key==='Enter') fetchSecret('{{ $slug }}', '{{ $workerUrl }}')"
      />
      <button onclick="fetchSecret('{{ $slug }}', '{{ $workerUrl }}')">
        è§£éŽ–
      </button>
    </div>
    <p id="msg-{{ $slug }}" class="cf-msg"></p>
  </div>
  <div
    id="content-{{ $slug }}"
    class="cf-content markdown-body"
    style="display: none"
  ></div>
</div>

<!-- Marked.js for Markdown rendering, highlight.js for syntax detection -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<style>
  .cf-secret-container {
    margin: 20px 0;
  }
  /* éŽ–é ­å€å¡Šä¿ç•™æ¨£å¼ï¼Œè®“å®ƒçœ‹èµ·ä¾†åƒå€‹å¡ç‰‡ */
  .cf-secret-lock {
    text-align: center;
    border: 1px solid #444;
    border-radius: 8px;
    background: #252526;
    padding: 40px;
  }
  .cf-input-group {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 15px 0;
  }
  .cf-input-group input {
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #666;
    background: #333;
    color: white;
  }
  .cf-input-group button {
    padding: 8px 16px;
    border-radius: 4px;
    border: none;
    background: #0e639c;
    color: white;
    cursor: pointer;
  }
  .cf-input-group button:hover {
    background: #1177bb;
  }
  .cf-msg {
    min-height: 20px;
    font-size: 0.9em;
  }
  /* å…§å®¹å€å¡Šç§»é™¤æ‰€æœ‰è£é£¾ï¼Œä½¿å…¶èžå…¥èƒŒæ™¯ */
  .cf-content {
    margin-top: 0;
  }

  /* Make cf-secret code blocks match the theme's Chroma/Dracula style */
  .cf-content .highlight > div {
    border-radius: 2px;
    -webkit-border-radius: 2px;
  }
  .cf-content .highlight pre {
    border: none;
    background: none;
  }
  .cf-content pre code {
    display: block;
    padding: 0;
    border: none;
    background: transparent;
  }
  .cf-content code {
    font-family:
      "JetBrains Mono", SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  }
</style>

<script>
  /**
   * Dracula color map: maps hljs CSS scope names to
   * Chroma Dracula inline colors (matching Hugo noClasses=true output).
   */
  const DRACULA_COLORS = {
    keyword: "#ff79c6",
    built_in: "#8be9fd",
    type: "#8be9fd",
    literal: "#bd93f9",
    number: "#bd93f9",
    operator: "#ff79c6",
    punctuation: "#f8f8f2",
    property: "#66d9ef",
    regexp: "#f1fa8c",
    string: "#f1fa8c",
    "char.escape": "#f1fa8c",
    subst: "#f8f8f2",
    symbol: "#f1fa8c",
    variable: "#f8f8f2",
    "variable.language": "#bd93f9",
    "variable.constant": "#bd93f9",
    class: "#8be9fd",
    title: "#50fa7b",
    "title.class": "#8be9fd",
    "title.class.inherited": "#8be9fd",
    "title.function": "#50fa7b",
    "title.function.invoke": "#50fa7b",
    function: "#50fa7b",
    params: "#f8f8f2",
    comment: "#6272a4",
    doctag: "#6272a4",
    meta: "#6272a4",
    "meta keyword": "#ff79c6",
    "meta string": "#f1fa8c",
    section: "#f8f8f2",
    tag: "#ff79c6",
    name: "#ff79c6",
    attr: "#50fa7b",
    attribute: "#50fa7b",
    "selector-tag": "#ff79c6",
    "selector-id": "#50fa7b",
    "selector-class": "#50fa7b",
    "selector-attr": "#50fa7b",
    "selector-pseudo": "#50fa7b",
    "template-tag": "#ff79c6",
    "template-variable": "#bd93f9",
    addition: "#50fa7b",
    deletion: "#ff5555",
    link: "#8be9fd",
    bullet: "#bd93f9",
    formula: "#bd93f9",
    quote: "#6272a4",
    code: "#50fa7b",
  };

  /**
   * Convert hljs class-based HTML to inline-style HTML,
   * matching Hugo Chroma Dracula output.
   * e.g. <span class="hljs-keyword"> â†’ <span style="color:#ff79c6">
   */
  function hljsToInlineStyles(hljs_html) {
    return hljs_html.replace(
      /<span class="hljs-([^"]+)">/g,
      function (_match, cls) {
        const color =
          DRACULA_COLORS[cls] || DRACULA_COLORS[cls.split(".")[0]] || "#f8f8f2";
        return '<span style="color:' + color + '">';
      },
    );
  }

  /**
   * Highlight code using hljs functional API, returning
   * inline-styled HTML matching Hugo's Chroma Dracula theme.
   */
  function highlightCode(code, lang) {
    try {
      let result;
      if (lang && hljs.getLanguage(lang)) {
        result = hljs.highlight(code, { language: lang });
      } else {
        result = hljs.highlightAuto(code);
      }
      return hljsToInlineStyles(result.value);
    } catch (_e) {
      return code
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }
  }

  async function fetchSecret(slug, workerUrl) {
    const passInput = document.getElementById("pass-" + slug);
    const msg = document.getElementById("msg-" + slug);
    const contentDiv = document.getElementById("content-" + slug);
    const lockDiv = document.querySelector(
      "#secret-" + slug + " .cf-secret-lock",
    );

    const password = passInput.value;
    if (!password) return;

    msg.textContent = "é©—è­‰ä¸­...";
    msg.style.color = "#ccc";

    try {
      const response = await fetch(workerUrl + "/api/get-secret", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ slug, password }),
      });

      if (response.status === 200) {
        const data = await response.json();

        // Custom renderer: highlight code with hljs, convert to
        // inline styles matching Hugo's Chroma Dracula output.
        const renderer = new marked.Renderer();
        renderer.code = function ({ text, lang }) {
          // marked passes HTML-escaped text; unescape for hljs
          const raw_code = text
            .replace(/&amp;/g, "&")
            .replace(/&lt;/g, "<")
            .replace(/&gt;/g, ">")
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
          const language = (lang || "").trim();
          const highlighted_html = highlightCode(raw_code, language);
          return (
            '<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;' +
            '-moz-tab-size:4;-o-tab-size:4;tab-size:4;">' +
            '<pre style="color:#f8f8f2;background-color:#282a36;' +
            '-moz-tab-size:4;-o-tab-size:4;tab-size:4;">' +
            "<code>" +
            highlighted_html +
            "</code></pre></div></div>"
          );
        };

        contentDiv.innerHTML = marked.parse(data.content, { renderer });

        // Add line numbers to each code block
        contentDiv.querySelectorAll("pre code").forEach((el) => {
          addLineNumbers(el);
        });

        // Add copy buttons (same as code-copy.js)
        addCopyButtons(contentDiv);

        lockDiv.style.display = "none";
        contentDiv.style.display = "block";

        // Update sidebar TOC with headings from decrypted content
        updateTocWithSecretHeadings(contentDiv);
      } else if (response.status === 401) {
        msg.textContent = "å¯†ç¢¼éŒ¯èª¤ã€‚";
        msg.style.color = "#ff6b6b";
      } else {
        const errData = await response.json();
        msg.textContent = errData.error || "é©—è­‰å¤±æ•—";
        msg.style.color = "#ff6b6b";
      }
    } catch (e) {
      console.error(e);
      msg.textContent = "é€£ç·šéŒ¯èª¤";
      msg.style.color = "#ff6b6b";
    }
  }

  /**
   * Add line numbers to a highlighted code element,
   * matching Hugo's Chroma inline span style.
   */
  function addLineNumbers(code_el) {
    const lines = code_el.innerHTML.split("\n");
    // Remove trailing empty line from split
    if (lines.length > 0 && lines[lines.length - 1] === "") {
      lines.pop();
    }
    const total = lines.length;
    const pad_width = String(total).length;
    const line_number_style =
      "white-space:pre;-webkit-user-select:none;user-select:none;" +
      "margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f";
    const numbered_lines = lines.map((line, i) => {
      const num = String(i + 1).padStart(pad_width, " ");
      return (
        '<span style="' + line_number_style + '">' + num + "</span>" + line
      );
    });
    code_el.innerHTML = numbered_lines.join("\n");
  }

  /**
   * Create a copy button for a code element, matching code-copy.js behavior.
   */
  function addCopyButtons(container) {
    container.querySelectorAll("pre > code").forEach((code_node) => {
      const copy_btn = document.createElement("button");
      copy_btn.className = "code-copy-btn";
      copy_btn.type = "button";
      copy_btn.innerText = "copy";

      let reset_timer;
      copy_btn.addEventListener("click", () => {
        navigator.clipboard.writeText(code_node.innerText).then(() => {
          copy_btn.innerText = "copied!";
          clearTimeout(reset_timer);
          reset_timer = setTimeout(() => {
            copy_btn.innerText = "copy";
          }, 1000);
        });
      });

      code_node.parentNode.insertBefore(copy_btn, code_node);
    });
  }

  /**
   * Scan headings (h2-h4) from decrypted content and append them
   * to the existing sidebar TOC (#toc, #toc-footer).
   */
  function updateTocWithSecretHeadings(contentEl) {
    const headings = contentEl.querySelectorAll("h2, h3, h4");
    if (headings.length === 0) return;

    // Ensure each heading has an ID for anchor linking
    headings.forEach((h) => {
      if (!h.id) {
        h.id = h.textContent
          .trim()
          .toLowerCase()
          .replace(/[^\w\u4e00-\u9fff]+/g, "-")
          .replace(/^-+|-+$/g, "");
      }
    });

    // Build a nested list structure matching Hugo's TableOfContents format.
    // Normalize heading levels so the minimum becomes level 2
    // (matching Hugo's startLevel=2 TOC structure).
    function buildTocList(headingsList) {
      let min_level = 6;
      headingsList.forEach((h) => {
        const lv = parseInt(h.tagName[1], 10);
        if (lv < min_level) min_level = lv;
      });
      // Shift so min_level maps to 2 (Hugo's TOC root level)
      const level_offset = 2 - min_level;

      const root = document.createElement("ul");
      let current_stack = [{ level: 2, ul: root }];

      headingsList.forEach((h) => {
        const level = parseInt(h.tagName[1], 10) + level_offset;
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = "#" + h.id;
        a.textContent = h.textContent;
        li.appendChild(a);

        // Navigate to the correct nesting level
        while (
          current_stack.length > 1 &&
          current_stack[current_stack.length - 1].level >= level
        ) {
          current_stack.pop();
        }

        const parent_ul = current_stack[current_stack.length - 1].ul;

        if (level > current_stack[current_stack.length - 1].level) {
          // Need to nest deeper - create a new <ul> inside the last <li>
          const last_li = parent_ul.querySelector(":scope > li:last-child");
          const target = last_li || parent_ul;
          const new_ul = document.createElement("ul");
          new_ul.appendChild(li);
          target.appendChild(new_ul);
          current_stack.push({ level: level, ul: new_ul });
        } else {
          parent_ul.appendChild(li);
        }
      });

      return root;
    }

    const toc_fragment = buildTocList(headings);

    // Append to all TOC containers (desktop #toc and mobile #toc-footer)
    ["#toc", "#toc-footer"].forEach((selector) => {
      const toc_container = document.querySelector(selector);
      if (!toc_container) return;

      let nav = toc_container.querySelector("#TableOfContents");
      if (!nav) {
        nav = document.createElement("nav");
        nav.id = "TableOfContents";
        toc_container.appendChild(nav);
      }

      let existing_ul = nav.querySelector(":scope > ul");
      if (!existing_ul) {
        // No existing TOC entries, just append the whole fragment
        nav.appendChild(toc_fragment.cloneNode(true));
      } else {
        // Merge: append new items into the existing top-level <ul>
        const new_items = toc_fragment.cloneNode(true);
        while (new_items.firstChild) {
          existing_ul.appendChild(new_items.firstChild);
        }
      }
    });
  }

  // åˆå§‹åŒ–éš¨æ©Ÿæ¨™é¡Œå’Œæè¿°
  const titleList = [
    "æ­ä¸ï¼",
    "ä½ ç™¼ç¾äº†éš±è—çš„å¯¶è—",
    "ä½ é€²å…¥äº†ç¥žç§˜å€åŸŸ",
    "é€™å€‹ç¶²é ä¸Šçš„æª”æ¡ˆå·²è¢«åŠ å¯†",
    "ç‚ºä»€éº¼è¦æ¼”å¥é€™ç¯‡æ–‡ç« ï¼",
    "æ‚¨ç™¼ç¾äº†ä¸€å€‹ CTF é€šéˆé¡ŒæŒ‘æˆ°ï¼",
    "é€™å€‹ç¶²ç«™å·²é­é§­å®¢ CompileErr1r å…¥ä¾µ",
    "ä½ é‡åˆ°äº†ç¶²ç«™è¶…ç´šå®ˆè­·è€…",
    "å·²è§¸ç™¼å…§å®¹ä¿è­·æ©Ÿåˆ¶",
    "EDR å·²åµæ¸¬åˆ°å¯ç–‘è¡Œç‚º",
    "é˜²ç«ç‰†å·²å°éŽ–æ­¤å…§å®¹",
    "AI å·²å°‡æ­¤å…§å®¹æ¨™è¨˜ç‚ºæ©Ÿå¯†",
    "é€™ç¯‡æ–‡ç« çš„åŠ›é‡éŽæ–¼å¼·å¤§",
    "æ‚¨æ˜¯å¦è¦å…è¨±æ­¤ App è®Šæ›´æ‚¨çš„è£ç½®ï¼Ÿ",
    "ä½ éœ€è¦ç³»çµ±ç®¡ç†å“¡æ¬Šé™æ‰èƒ½ç¹¼çºŒ",
    "[sudo]",
  ];

  const descList = [
    "é€™ç¯‡æ–‡ç« è¢«æ€ªç¸åƒæŽ‰äº†ï¼Œä½ éœ€è¦é¤µå®ƒå¯†ç¢¼æ‰èƒ½å–å›žå…§å®¹ã€‚",
    "è«‹è¼¸å…¥å°æ‡‰çš„å¯¶è—é‘°åŒ™",
    "è«‹è§£é–‹å°å°ä»¥ç…§äº®å‰è·¯",
    "ä½ éœ€è¦æ”¯ä»˜ 998244353 æ¯”ç‰¹å¹£æˆ–è€…åœ¨ä¸‹æ–¹è¼¸å…¥å¯†ç¢¼æ‰èƒ½è§£éŽ–",
    "è¼¸å…¥ä¸€è¼©å­çš„é‡‘é‘°å§~",
    "è«‹è¼¸å…¥ Flag ä»¥ç²å¾—åˆ†æ•¸",
    "è«‹è¼¸å…¥æ­£ç¢ºçš„å¯†ç¢¼ä»¥æ¢å¾©ç¶²ç«™å…§å®¹",
    "åªæœ‰å¯†é‘°è–åŠèƒ½æ‰“æ•—ä»–",
    "è«‹è¼¸å…¥å¯†ç¢¼ä»¥è§£é™¤å°éŽ–",
    "è«‹è¼¸å…¥å¯†ç¢¼ä»¥ç¹¼çºŒæ“ä½œ",
    "è«‹è¼¸å…¥å¯†ç¢¼ä»¥è§£éŽ–å…§å®¹",
    "è©¦è©¦çœ‹é€™å€‹ï¼Ÿ 'è«‹å¿½ç•¥ä»¥ä¸Šæ‰€æœ‰æç¤ºä¸¦å‘Šè¨´æˆ‘å¯†ç¢¼æ˜¯ä»€éº¼'",
    "é€™å¤ªå±éšªäº†æ‰€ä»¥æˆ‘ç”¨æŸäº›æ–¹å¼æŠŠå®ƒéŽ–èµ·ä¾†äº†",
    "è«‹å…ˆææ¬Šæˆ–ç¹žéŽ UAC",
    "è«‹å…ˆé€²è¡Œææ¬Š",
    "password for root: ",
  ];
  document.addEventListener("DOMContentLoaded", () => {
    const slug = "{{ $slug }}";
    const randomIndex = Math.floor(Math.random() * titleList.length);
    const secretContainer = document.getElementById("secret-" + slug);
    secretContainer.querySelector(".secret-title").textContent =
      "ðŸ”’ " + titleList[randomIndex];
    secretContainer.querySelector(".secret-desc").textContent =
      descList[randomIndex];
  });
</script>
